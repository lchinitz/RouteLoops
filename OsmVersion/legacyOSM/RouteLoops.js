//Make sure this code has a valid token.  A restricted token!

const { protocol, hostname, port } = window.location;
var geocoder;
var elevator;

//The map, related stuff, and other icons
var map,RoutingControl;
var rlPath,rawPath,guidepointPath;
var allPoints;
var directionMarkers = [];
var center;
var baseSet = new Boolean();
var BaseMarker;
var BaseMarkerAction;
var homeIcon = './RLimages/Home.png';
var pitchMarker;
var BaseLocation;
var W3CLocation;
var browserSupportFlag =  new Boolean();
var gotW3Clocation = new Boolean();
var countW3C = 0;

//Input stuff
var CookiesChecked = false;

//The current route
var travelMode,travelDirection,travelHeading;
var allowFerries = false;
var avoidHighways = true;
//Stuff for keeping a copy of the route before this one
var tcxSpeed;
var markerArray = [];
var markerPosition = [];
var markerLabel = [];
var markerTime = [];
var Country;
var tooLong = 0;
var tooShort = 0;
var scaleFactor = 0.80;
var scaleCount = 0;
var currentRouteData = [];  //An array to start storing away anything you want to know on a point-by-point basis.
var spacedRouteData = []; //The array of data generated by interpolating Google's returned data.
var useThis = spacedRouteData;
var fixedPoints = new Array;
var rlPoints = new Array();
var rlPointsNew = new Array(); //use this for cleaning up the little tails
var routeResult;
var routeLatLng = new Array;
var totalDistanceInCurrentUnits;
var requestedLengthInMeters;
var targetLengthInMeters; //This one is adjusted by the scale factor to try and zero in on the length you want.
var rlPoints = new Array();
var Velocity,Time,Dist;
var countCalcs=0;

//Previous routes
var resultHistory = new Array;
var historyPointer;
var storeInHistory;
var lastRemoved = -1;

// Stuff for when a URL contains inputs (a permalink)
var uBase;
var urlPoints = new Array();
var utMode;
var ulen;
var uuS;
var uClean;
var parsedUrl = false;
var haveGoodUrl = false;
// Stuff for when that permalink stuff is old, from an old version.
var haveOldUrl = new Boolean();
var haveEmbedded = new Boolean();
var oldUrlLng,oldUrlLat;
var oldUrlLen;
var oldUrlRnd;
var OldUrlAllow;

//Mile markers
var numMM;
var mileMarkers = [];
var rideStart;  //This is the day and time of the start of the ride, used for predicting the weather.

//Stuff for integration with the RouteLoops engine
var RlUrl;
var RLroutes = [];
var myText;

var elevDist = [];

//For importing GPS files
var pointArray = [];
var importedPolyline = [];
var importedTracks = new Array;

//Cleaning up the tails
var DoClean = true;
var countCalcs = 0; //Count how many times you call calcRoute()
var circleArray = [];
var circleAsked = [];
var wayFlags = [];

//Various flags
var ePlot = false;
var rtTraffic = false;
var rtWeather = false;
var showingMarkers = false;

//Ruler stuff
var measuring = false;
var rulerMarkers = new Array;
var rulerClickListener;
var rulerLine;

//Language
var Language = new String();

//Units
var MILES2KM = 5280*12*2.54/100/1000;
var KM2MILES = 1/MILES2KM;
var Feet2Meters = 12*2.54/100;

//Cue sheet
var cueText;
var Directions;

//...................................................................
function initialize() {

    extractLanguage();
    
    var currentURL = location.href;
    
     
    var query="";
    if(currentURL.indexOf("?")>=0)
	var query = currentURL.slice(currentURL.indexOf("?"),currentURL.length);
    else
	var query = "";
    
    var currentTime = new Date();
    var year = currentTime.getFullYear();
    //document.getElementById("crYear").innerHTML = year;

  //Find out if you should move to the mobile version.
  var navAgent = navigator.userAgent;
  if(navAgent.toLowerCase().indexOf("android") > -1
     || navAgent.toLowerCase().indexOf("ipod") > -1
     || navAgent.toLowerCase().indexOf("iphone") > -1
     || navAgent.toLowerCase().indexOf("ipad") > -1)
    var answer = confirm("Go to mobile site?");
  if(answer)location.replace("http://www.routeloops.com/mobile"+query);

  //Listener that lets you read in a track from a file.
  //document.getElementById("trackRead").addEventListener('change',importTrack,false);
  
  baseSet = false;

  //Permalinks always win, so check them first.
  //if(query.length>0)checkForPermalink(currentURL);

  //But, maybe you don't have a permalink.  Actually, that's the usual case.  So now check for cookies.
  if(!baseSet)checkForCookies();

  getLength();
  travelMode = document.getElementById("travelMode").value;
  travelDirection = document.getElementById("travelDirection").value;
  travelHeading = document.getElementById("travelHeading").value;
  var Lat,Lng;
  if(baseSet){ Lat = BaseLocation.lat; Lng = BaseLocation.lng; }
  else{ Lat = 40.735383; Lng = -73.984655; }

    //Create the map

    map = L.map('map').setView([42.3, -71.3], 8);

    const tiles = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
	maxZoom: 18,
	attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    var theMode     = "cycling-road";
    if (travelMode=="0")   theMode = "driving-car";
    else if (travelMode=="1") theMode = "cycling-road";
    else if (travelMode=="2") theMode = "foot-walking";
    
    const theRouter = "MapBox";
    var routerToUse = null;
    if (theRouter=="OSM") routerToUse = new L.Routing.OSRMv1({"profile": `${theMode}`});
    if (theRouter=="MapBox"){
	var theToken = 'A valid token';
	var theProfile = "cycling";
	if (theMode.indexOf("driving")>=0) theProfile = "driving";
	if (theMode.indexOf("cycling")>=0) theProfile = "cycling";
	if (theMode.indexOf("walking")>=0) theProfile = "walking";
	if (theMode.indexOf("foot")>=0) theProfile = "walking";
	//Change this to use the input from the query string
	const urlParams = new URLSearchParams(window.location.search);
	if (urlParams.has("mode")) {
	    var mode = urlParams.get("mode");
	    if (mode.indexOf("0")>=0) theProfile = "driving";
	    if (mode.indexOf("1")>=0) theProfile = "cycling";
	    if (mode.indexOf("2")>=0) theProfile = "walking";
	    if (theProfile=="driving") document.getElementById("travelMode").value="0";
	    if (theProfile=="cycling") document.getElementById("travelMode").value="1";
	    if (theProfile=="walking") document.getElementById("travelMode").value="2";
	}
	routerToUse = new L.Routing.mapbox(theToken,{profile:`mapbox/${theProfile}`});	
    }
    RoutingControl = L.Routing.control({
	waypoints:[],
	lineOptions: {styles: [{color: 'red', opacity: 1, weight: 3}]},
	router: routerToUse				     
    }).addTo(map);
    
    RoutingControl.on("routesfound", async (response) => {
	var theResponse = response;
	allPoints = [];
	for (const point of theResponse.routes[0].coordinates) allPoints.push({lat:point.lat,lng:point.lng});
	for (const item of  theResponse.routes[0].instructions) allPoints[item.index].instructions = item.text;
	//Based on the drag action, find the current set of waypoints.
	var newWaypoints = [];
	for (var i=1;i<theResponse.waypoints.length-1;i++){
	    var thisWaypoint = theResponse.waypoints[i];
	    newWaypoints.push({lat:thisWaypoint.latLng.lat, lng:thisWaypoint.latLng.lng});
	}
	currentWaypoints.length=0;
	for (const waypoint of newWaypoints) currentWaypoints.push(waypoint);
	var ApiHeaders =  {'Accept': 'application/json','Content-Type': 'application/json'};	    
	var data = {allPoints:allPoints};
	var url = `${protocol}//${hostname}:${port}/modifyDirections`;
	var theResp = await fetch(url,{method:'POST',body:JSON.stringify(data),headers:ApiHeaders});
	var theJson = await theResp.json();
	distDisplay = theJson.totalDistanceKm;
	allPoints.length = 0;
	for (const point of theJson.modifiedAllPoints) allPoints.push(point);
	var units = document.getElementById("unitSystem").value;
	if(units=="0")units="imperial";
	else if (units=="1")units="metric";
	if (units=="imperial"){
	    distDisplay = distDisplay*1000*100/2.54/12/5280;
	    document.getElementById("total_1").innerHTML = `${distDisplay.toFixed(1)} miles`;
	}
	else{
	    document.getElementById("total_1").innerHTML = `${distDisplay.toFixed(1)} km`;
	}
	totalDistanceInCurrentUnits = distDisplay;
	try{map.removeLayer(rlPath);}catch(err){}
	//Set markers at the locations where you have directions.
	for (const marker of directionMarkers) marker.map = null;
	directionMarkers.length=0;
	var countInstructions = 0;
	for (const point of allPoints){
	    if (point.hasOwnProperty("instructions")){
		countInstructions += 1;
		point.count = countInstructions;
		var useInstruction = `${countInstructions}: ${point.instructions}`;
		var marker = new L.Marker([point.lat, point.lng],{title:useInstruction});
		marker.addTo(map);
		directionMarkers.push(marker);
	    }
	}
	showDirectionMarkers();
    });
        
  if(baseSet){
    createBaseMarker();
    codeAddress();
  }

  //Initialize permalinks
  var permalink;
  var protocol = location.protocol;
  var host = location.host;
  var path = location.pathname;
  permalink = protocol+"//"+host+path;
  //document.getElementById("permalink").href = permalink;

  if(query.length>0 && baseSet)calcRoute(); //So, if you came in with a permalink, create the route.

}
//--------------------------------------
function changeMode(){
    var theMode = document.getElementById('travelMode').value;
    const currentUrl = window.location.href;
    var split = currentUrl.split("?");
    var url = split[0];
    url += `?mode=${theMode}`;
    window.open(url,"_self")
    return;
}
//.......................................
function showDirectionMarkers(){
    //if (document.getElementById("directionMarkers").checked){
    if (false){
	//for (const marker of directionMarkers) marker.addTo(map);
	displayMarker(0);
    }
    else{
	for (const marker of directionMarkers) map.removeLayer(marker);
    }
    return;
}
//--------------------------------------
function displayMarker(index){
    if (index<directionMarkers.length){
	var marker = directionMarkers[index];
	marker.addTo(map);
	index+=1;
	if (index<directionMarkers.length) setTimeout( ()=> {displayMarker(index)},200);
    }
    return;
}

//......................................................................................
function getW3Clocation()
{
  //alert("trying w3c");
  countW3C++;
  browserSupportFlag = true;
  navigator.geolocation.getCurrentPosition(function(position) {
      W3CLocation = new google.maps.LatLng(position.coords.latitude,position.coords.longitude);
      gotW3Clocation = true;
      BaseLocation = W3CLocation;
      map.setCenter(BaseLocation);
      map.setZoom(13);
      //alert("Got W3C location " + W3CLocation.toString());
      var infowindow = new google.maps.InfoWindow();
      //contentString = "You are here.<br>Double click on map to set this location as your starting point.";
      //document.getElementById("address").value = BaseLocation.toString();
      document.getElementById("address").value = BaseLocation.lat() + ',' + BaseLocation.lng();
      codeAddress();
      //infowindow.setOptions({maxWidth: 300});
      //infowindow.setContent(contentString);
      //infowindow.setPosition(W3CLocation);
      //infowindow.open(map);
    }, 
    function() {
      BaseLocation = new google.maps.LatLng(42,-71);
      gotW3Clocation = false;
      //alert("Did not get W3C location " + W3CLocation.toString());
    },
    {maximumAge:1000}
    );
  return;
}
//..................................................................................................
function checkForPermalink(currentURL)
{

    //Quick check for a URL intended to enable routeloops from the Chrome search bar.
    var split1 = currentURL.split('?');
    var qs = split1[1];
    var split2 = qs.split('&');
    
    if(split2.length==2){
	var result = {};
	for (var i=0;i<split2.length;i++){
	    var split3 = split2[i].split('=');
	    if(split3[0] == 'address')  result.address = split3[1];
	    if(split3[0] == 'distance')  result.distance = split3[1];
	}
	if(result.address && result.distance){
	    baseSet = true;
	    document.getElementById('address').value = result.address;
	    document.getElementById('length').value = result.distance;
	    codeAddress()
		.then(function(){
		    redrawOrNew(-1);
		})
		.then(null,function(err){
		    console.log('Some sort of problem in using the quick URL.... ' + err)
		});
	}
    }

    else{
    
	if(parseUrl(currentURL)) //There is a valid permalink in this URL, so use it.
	{
	    if(uBase)document.getElementById("address").value = uBase.lat() +","+ uBase.lng();
	    BaseLocation = new google.maps.LatLng(uBase.lat(),uBase.lng());
	    baseSet = true;
	    for(var i=0;i<urlPoints.length;i++)rlPoints[i] = new google.maps.LatLng(urlPoints[i].lat(),urlPoints[i].lng());
	    travelMode = utM;
	    document.getElementById("travelMode").value = utM;
	    if(uuS==0)
		document.getElementById("length").value = ulen;
	    else if(uuS==1)
		document.getElementById("length").value = (ulen*KM2MILES).toFixed(2);
	    if(!uClean){
		DoClean=true;  //make sure it's on, and then...
		toggleAutoClean();  //shut it off.
	    }
	    else if(uClean){
		DoClean=false;  //make sure it's off, and then...
		toggleAutoClean();  //turn it on.
	    }
	}
	else
	{
	    //alert("Bad return from parseURL");
	    //However, check to see if there is an old URL that was successful.
	    if(haveOldUrl)
	    {
		document.getElementById("address").value = oldUrlLat +","+ oldUrlLng;
		BaseLocation = new google.maps.LatLng(oldUrlLat,oldUrlLng);
		baseSet = true;
	    }
	    if(haveEmbedded)
	    {
		//alert("Have an embedded URL");
		parsedUrl = true;
		//calcRoute();
	    }
	}
	
    }
    return;
}
//......................................................................................
function checkForCookies()
{
  //Check to see if we have any cookie information to start with
  var CookieLength  = readCookie("length");
  if(CookieLength!=null)document.getElementById("length").value = CookieLength;
  var CookieTM      = readCookie("TM");
  if(CookieTM!=null)document.getElementById("travelMode").value = parseInt(CookieTM);
  var CookieTD      = readCookie("TD");
  if(CookieTD!=null)document.getElementById("travelDirection").value = parseInt(CookieTD);
  var CookieUS      = readCookie("US");
  if(CookieUS!=null)document.getElementById("unitSystem").value = parseInt(CookieUS);
  var CookieClean   = readCookie("Clean");
  var CookieAddress = readCookie("address");
  if(CookieAddress!=null)
    {
      document.getElementById("address").value = CookieAddress;
      $("#address").removeClass("watermark"); //remove class when user focus on the textbox
      codeAddress();
      if(CookieClean == "Turn AutoClean On")toggleAutoClean();
    }

  if(document.getElementById("unitSystem").value == 0)
    {document.getElementById("total_1").innerHTML = "0 miles";
      document.getElementById("inputUnits").innerHTML = "miles";
      document.getElementById("tcxUnits").innerHTML = "feet";
      document.getElementById("tcxSpeedUnits").innerHTML = "mph";
    }
  else
    {document.getElementById("total_1").innerHTML = "0 kilometers";
      document.getElementById("inputUnits").innerHTML = "kilometers";
      document.getElementById("tcxUnits").innerHTML = "meters";
      document.getElementById("tcxSpeedUnits").innerHTML = "kph";
    }

    return;
}
//......................................................................................
function importTrack(evt)
{
  
  if(typeof evt == 'undefined')
    {
      alert("Please choose a file using the file selector button.");
      document.getElementById("trackRead").value = null;
      return;
    }

  f = evt.target.files[0];

  if(f)
    {
      var r = new FileReader();
      r.onload = function (e)
	{
	  var contents = e.target.result;
	  if(contents.length>0)
	    {
	      contents = contents.replace(/&lt;/g,"<");
	      contents = contents.replace(/&gt;/g,">");
	      parseText(contents);
	    }
	}
      r.readAsText(f);
    }
  else
    {
      alert("Failed to load file.");
    }
  return;
}
//......................................................................................
async function codeAddress() {

    var address = document.getElementById("address").value;
    var encoded = encodeURI(address);

    //Geocode this starting location in to a Lat/Lng pair.
    var url = `${protocol}//${hostname}:${port}/geocode?location=${encoded}`;
    var theResp = await fetch(url);
    var theJson = await theResp.json();    
    var theLatLng = {lat:theJson.features[0].geometry.coordinates[1],lng:theJson.features[0].geometry.coordinates[0]};

    map.setView(new L.LatLng(theLatLng.lat,theLatLng.lng),18);

    //Put a house marker at the start/end point.
    homeIcon = L.icon({
	iconUrl: './RLimages/Home.png'	
    });

    try{ map.removeLayer(BaseMarker);} catch(err){}
    BaseMarker = L.marker([theLatLng.lat, theLatLng.lng], {icon: homeIcon,draggable:true,title:address}).addTo(map);
    BaseLocation = theLatLng;
    baseSet = true;

    return;
}
//..........................................................................
function handleFixed(nFix) 
{

  for(var i=0;i<fixedPoints.length;i++)fixedPoints[i].marker.setMap(null);
  fixedPoints.length=0;  //Temporary, while we are only allowing a single fixed waypoint.

  var id = "fixedPoint_" + nFix;
  var address = document.getElementById(id).value;
  geocoder.geocode( { 'address': address}, function(results, status) {
    if (status == google.maps.GeocoderStatus.OK) 
      {
	var location = results[0].geometry.location;
	var marker = placeMarker(location,'Fixed Waypoint');
	marker.setTitle("Waypoint @ " + results[0].formatted_address);
	document.getElementById(id).value = results[0].formatted_address;
	var markerAction = google.maps.event.addListener(marker,'dragend',function(mEvent){
	    var moveTo = mEvent.latLng;
	    document.getElementById(id).value = mEvent.latLng.toString();
	    handleFixed(nFix);
	});
	fixedPoints.push({marker:marker, action:markerAction});
      } 
    else 
      {
	if(address.length!=0) alert("Geocode of " + address + " returned: " + status);
      }
    });

  return;
}
//........................................................................
async function getRLpoints()
{

    var BaseIsSet = false;
    try{
	var test = BaseLocation.lat;
	BaseIsSet = true;
    }
    catch(err){}
    if (!BaseIsSet){
	alert("You need to set the start/end point, first.");
	return;
    }
    
  for(var i=0;i<importedTracks.length;i++)
    if(importedTracks[i])importedTracks[i].setMap(null);

  historyPointer = resultHistory.length;
  storeInHistory=true;
  if(pitchMarker)pitchMarker.setMap(null);

  if(fixedPoints.length>0)
    fixedPointRoute(targetLengthInMeters);

  else
    {
	//Pick one of the methods for generating the points.
	theLatLng = BaseLocation;
	var pickMethod = Math.floor(3*Math.random());
	var theRotation  = document.getElementById("travelDirection").value;
	if (theRotation=="0")theRotation="clockwise";
	else if (theRotation=="1")theRotation="counterclockwise";
	var theDirection= document.getElementById("travelHeading").value;
	var theDistance = targetLengthInMeters/1000;
	var theUnits = "metric";
	var url = `${protocol}//${hostname}:${port}/getRLpoints?lat=${theLatLng.lat}&lng=${theLatLng.lng}`;
	url += `&dist=${theDistance}&units=${theUnits}&rotation=${theRotation}&direction=${theDirection}`;
	var theMethod= "random";
	if (pickMethod==0) theMethod = "circular";
	else if (pickMethod==1) theMethod = "rectangular";
	else if (pickMethod==2) theMethod = "figure8";
	url += `&method=${theMethod}`;
	var theResp = await fetch(url);
	var theJson = await theResp.json();
	var initialWaypoints = JSON.parse(JSON.stringify(theJson));
	rlPoints.length=0;
	for (const wpt of initialWaypoints) rlPoints.push(wpt);
    }

  return;
}
//.....................................................................................
async function calcRoute() {

  if(rlPoints.length==0)return;  //There is no reason to be here, yet.  You might have gotten here because people were changing Settings.

    countCalcs++;

    //Add the starting location as both the first, and the last, guide point.
    var guidePoints = [];
    guidePoints.push(new L.LatLng(BaseLocation.lat,BaseLocation.lng));
    for (const waypoint of rlPoints) guidePoints.push(new L.LatLng(waypoint.lat,waypoint.lng));
    guidePoints.push(new L.LatLng(BaseLocation.lat,BaseLocation.lng));
    
    //Draw these guide points on the map.

    guidepointPath = new L.Polyline(guidePoints, {color:'blue',weight:2,opacity: 1.0,smoothFactor: 1});
    guidepointPath.addTo(map);    

    //Get a bounding box used to zoom the map to a more reasonable size.
    const RLBounds = guidepointPath.getBounds();
    if (typeof waypointsIn == "undefined")
	map.fitBounds(RLBounds);

    //Call the directions service using the guide point as waypoints.
    var theMode       = document.getElementById("travelMode").value;
    if (theMode=="0") theMode = "driving-car";
    else if (theMode=="1") theMode = "cycling-road";
    else if (theMode=="2") theMode = "foot-walking";
    var inputHighways = document.getElementById("highways").value;
    if (inputHighways=="0") inputHighways = "yes";
    else inputHighways = "no";
    var inputFerries  = document.getElementById("ferryButton").value;    
    if (inputFerries=="0") inputFerries = "yes";
    else inputFerries = "no";
    var url = `${protocol}//${hostname}:${port}/directions?lat=${theLatLng.lat}&lng=${theLatLng.lng}`;
    url += `&mode=${theMode}&highways=${inputHighways}&ferries=${inputFerries}`;
    var waypointText= "";
    for (const waypoint of rlPoints) waypointText += `${waypoint.lat},${waypoint.lng}|`;
    waypointText = waypointText.slice(0,-1);
    url += `&waypoints=${waypointText}`;
    var theResp = await fetch(url);
    var theJson = await theResp.json();
    
    if (theJson.hasOwnProperty("error")){
	alert(`The routing server has returned an error.  Try again with a slightly shorter route.  The error returned was "${theJson.error}"`);
	try{map.removeLayer(rlPath);}catch(err){}
	try{map.removeLayer(rawPath);}catch(err){}
	try{map.removeLayer(guidepointPath);}catch(err){}
	try{homeMarker.remove();}catch(err){}
	for (const marker of directionMarkers) map.removeLayer(marker);
	return;
    }
    else{
	allPoints = theJson.features[0].allPoints;
	var distDisplay = theJson.features[0].totalDistanceKm;
	
	//Draw the raw result on the map.  This has not yet been cleaned up by RouteLoops.
	var rawPoints = [];
	for (const point of allPoints) rawPoints.push(new L.LatLng(point.lat,point.lng));
	rawPath = new L.Polyline(rawPoints,{color:'green',weight:2,opacity:1.0,smoothFactor:1});
	rawPath.addTo(map);

	//Call a cleaning function until the result stabilizes
	var ApiHeaders =  {'Accept': 'application/json','Content-Type': 'application/json'};
	var keepGoing = true;
	if (!DoClean) keepGoing = false;
	var countCalcs = 0;
	var waypoints = [];
	for (const waypoint of rlPoints) waypoints.push(waypoint);
	lastCounts = {cleaned:-1,total:-1};
	while (keepGoing){
	    countCalcs += 1;

	    //Take allPoints and clean up the path.
	    var data = {LLs:allPoints};
	    var url = `${protocol}//${hostname}:${port}/cleanTails`;
	    var theResp = await fetch(url,{method:'POST',body:JSON.stringify(data),headers:ApiHeaders});
	    var cleanTailsJson = await theResp.json();

	    if (cleanTailsJson.cleanedUp > 0){ //You modified the path, so redo the whole thing with this modified path.
		//Generate the new set of allPoints.
		allPoints.length = 0;
		for (const point of cleanTailsJson.newPath) allPoints.push(point);

		//Based on the new allPoints, find the current set of waypoints.  Choose the closest points to the previous waypoints.
		newWaypoints = [];
		for (const waypoint of waypoints){
		    var closest = null;
		    for (const point of allPoints){
			var separation = Math.pow((waypoint.lat-point.lat),2) + Math.pow((waypoint.lng-point.lng),2)
			if (closest==null) closest = {point:point,separation:separation};
			if (separation < closest.separation) closest = {point:point,separation:separation};
		    }
		    newWaypoints.push(closest.point);
		}
		waypoints.length=0;
		for (const waypoint of newWaypoints) waypoints.push(waypoint);

		//Generate a new path based on this new set of waypoints.
		var url = `${protocol}//${hostname}:${port}/directions?lat=${theLatLng.lat}&lng=${theLatLng.lng}`;
		url += `&mode=${theMode}&highways=${inputHighways}&ferries=${inputFerries}`;
		var waypointText= "";
		for (const waypoint of waypoints) waypointText += `${waypoint.lat},${waypoint.lng}|`;
		waypointText = waypointText.slice(0,-1);
		url += `&waypoints=${waypointText}`;
		var theResp = await fetch(url);
		var directionsJson = await theResp.json();
		allPoints = directionsJson.features[0].allPoints;	    
	    }
	    
	    else{ //No change, so that's it.
		keepGoing = false;
	    }
	    
	    if (cleanTailsJson.cleanedUp==lastCounts.cleaned && allPoints.length==lastCounts.total){ //The modifications are not changing, so stop
		keepGoing = false;
	    }
	    else{
		lastCounts = {cleaned:cleanTailsJson.cleanedUp,total:allPoints.length};
	    }
	}

	
	try{var distDisplay = cleanTailsJson.distKm;}catch(err){}
	var units = document.getElementById("unitSystem").value;
	if (units=="0"){
	    distDisplay = distDisplay*1000*100/2.54/12/5280;
	    document.getElementById("total_1").innerHTML = `${distDisplay.toFixed(1)} miles`;
	}
	else{
	    document.getElementById("total_1").innerHTML = `${distDisplay.toFixed(1)} km`;
	}
	totalDistanceInCurrentUnits = distDisplay;    
	
	//document.getElementById('calcs').innerHTML = countCalcs;    
        
	//Draw the cleaned result on the map.
	var loopPoints = [];
	for (const point of allPoints) loopPoints.push(new L.LatLng(point.lat,point.lng));
	rlPath = new L.Polyline(loopPoints,{color:'red',weight:3,opacity:1.0,smoothFactor:1});
	rlPath.addTo(map);

	//Remove the other lines if that's desired.
	//var yes = confirm("Remove other lines?");
	var yes = true;
	if (yes){
	    map.removeLayer(rawPath);
	    map.removeLayer(guidepointPath);
	}

	currentWaypoints = JSON.parse(JSON.stringify(waypoints));    

	//This is a special section for OSM, to enable draggable routes.
	var wpts = [];
	wpts.push(new L.LatLng(theLatLng.lat,theLatLng.lng))    
	for (const waypoint of waypoints)wpts.push(new L.LatLng(waypoint.lat,waypoint.lng))    
	wpts.push(new L.LatLng(theLatLng.lat,theLatLng.lng))    
	RoutingControl.setWaypoints(wpts);
	
	
	// Keep a record of the requests that are made.
	var storage;
	storage = "Base="+BaseLocation.lat+":"+BaseLocation.lng;
	storage = storage + "&tM=" + theMode;
	storage = storage + "&len=" + document.getElementById("length").value;
	storage = storage + "&unitS=" + document.getElementById("unitSystem").value;
	storage = storage + "&address=" + document.getElementById("address").value;
	storage = storage + "&function=calcRoute";
	
	var fromHere = BaseLocation;
	var toHere = BaseLocation;
    }
        
    return;
  
}

//....................................................................................................................
function changeSpeed()
{
  var total = totalDistanceInCurrentUnits;
  var timeTot;
  var timeH=0;
  var timeM=0;
  var timeText;
  var speed = parseFloat(document.getElementById("tcxSpeed").value);


  timeTot = total/speed *60 *60; //time in seconds
  timeH = hours(timeTot);
  timeM = minutes(timeTot);
  if(timeH>0)timeText = timeH + " hours ";
  else timeText = "";
  if(timeM>0)timeText += timeM + " min ";
  else timeText += "";
  document.getElementById("routeTime").innerHTML = timeText;

  return;
 }
//....................................................................................................................
function fixedPointRoute(length)
{

  //How far is it to your fixed point?
  var distToFixed = computeDistanceBetween(BaseLocation,fixedPoints[0].marker.getPosition());

  if(distToFixed/requestedLengthInMeters > 0.5)
    {
      alert("The distance requested is less than half the straight line distance to the fixed waypoint.  No way to close a route.");
    }

  else
    {
      var brngToFixed = getBearing(BaseLocation,fixedPoints[0].marker.getPosition());
      /* Now, choose a direction in which to head, and go the distance such that the sum of the 3 legs 
	 (base to fixed, fixed to next, next to base) add up to the desired distance, length. */
      var minTurn = 20;  var maxTurn = 160;
      var direction = Math.random()* (maxTurn-minTurn) + minTurn;
      var side = Math.floor(2*Math.random());
      if(side==0) direction = direction;
      if(side==1) direction = -1* direction;
      var newBearing = brngToFixed + direction * Math.PI/180;
      var step = 0;
      var toHere;
      var allLegs = 0;
      while(allLegs < length)
	{
	  step += 1;  //Move out in steps of 1 meter.
	  toHere = getNewPointAlongBearing(fixedPoints[0].marker.getPosition(),step,newBearing);
	  allLegs = distToFixed + computeDistanceBetween(fixedPoints[0].marker.getPosition(),toHere) + computeDistanceBetween(toHere,BaseLocation);
	}

      var newBearing2 = newBearing + (1-side*2)*5*Math.PI/180;
      var toHere2 = getNewPointAlongBearing(fixedPoints[0].marker.getPosition(),step,newBearing2);

      /*
      placeMarker(toHere,"");
      new google.maps.Polyline({path:[BaseLocation,fixedPoints[0].marker.getPosition()],map:map});
      new google.maps.Polyline({path:[fixedPoints[0].marker.getPosition(),toHere],map:map});
      new google.maps.Polyline({path:[toHere,BaseLocation],map:map});
      */
      
      rlPoints.length=0;
      rlPoints.push(fixedPoints[0].marker.getPosition());
      rlPoints.push(toHere);
      rlPoints.push(toHere2);
    }

  return;
}
//...............................................................
function LatLngDist(lat1,lon1,lat2,lon2)
{
  //Check the distance between these points -- returns a value in km.
  var R = 6371; // km
  var dLat = (lat2-lat1)*Math.PI/180;
  var dLon = (lon2-lon1)*Math.PI/180; 
  var a = Math.sin(dLat/2) * Math.sin(dLat/2) +        
    Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) *         
    Math.sin(dLon/2) * Math.sin(dLon/2); 
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
  var d = R * c;
  //log("The separation between these points is " + d);
  return d;
}
//...............................................................

function hours(secs) {
  return Math.floor(Math.max(secs,0)/3600.0);
}
//...............................................................

function minutes(secs) {
  return Math.floor((Math.max(secs,0) % 3600.0)/60.0);
}
//...............................................................

function seconds(secs) {
  return Math.round(Math.max(secs,0) % 60.0);
}
//..................................................................
function padZeros(theNumber, max) {
  var numStr = String(theNumber);

  while ( numStr.length < max) {
    numStr = '0' + numStr;
  }

  return numStr;
}
//...........................................................................................
function placeMarker(location,text) {
  var marker = new google.maps.Marker({
    position: location, 
	draggable: true,
        map: map,
	title: text
	});
  //map.setCenter(location);
  
  return marker;
}
//............................................................................
function createBaseMarker()
{
  //Put down the base marker using the current base location.

  if(BaseMarker)BaseMarker.setMap(null);

  var Address = document.getElementById("address").value;

  BaseMarker = placeBase(BaseLocation,'Start/End at:' + Address);
  BaseMarker.setZIndex(1000);
  BaseMarker.setIcon(homeIcon);
  //lmclmc fix this!
  google.maps.event.removeListener(BaseMarkerAction);
  BaseMarkerAction = google.maps.event.addListener(BaseMarker,'dragend',baseLocation);

  return;
}
//.....................................................................................
function placeBase(location,text) {
  
  var marker = new google.maps.Marker({
    position:location,
	draggable:true,
	map:map,
	title: text
	});
  return marker;
}
//..........................................................................................
function baseLocation(evt)
{
  BaseLocation.lat = evt.srcObject.latLng.lat;
  BaseLocation.lng = evt.srcObject.latLng.lng;
  var baseL = BaseLocation.lat + "," + BaseLocation.lng;
  document.getElementById("address").value = baseL;
  revcodeLocation();

  return;
}
//..........................................................................................
function centerMap(lat,lng) {
    var center = new google.maps.LatLng(lat,lng);
    map.panTo(center);
}
//.........................................................................................
async function makeGPX()
{
    if(allPoints.length<=0){alert("You must have a track before you can create a GPX output file.");return;}
    
    var ApiHeaders =  {'Accept': 'application/json','Content-Type': 'application/json'};	    
    var data = {allPoints:allPoints};
    var url = `${protocol}//${hostname}:${port}/makeSparseGPX`;
    var theResp = await fetch(url,{method:'POST',body:JSON.stringify(data),headers:ApiHeaders});
    var theJson = await theResp.json();
    
    var OutText = theJson.gpx;
    var useName = theJson.name;
    var routeName = document.getElementById("tcxName").value.trim();
    if (routeName.length>0) useName = routeName;

    var blob = new Blob([OutText], {type: "text/plain;charset=utf-8"});
    saveAs(blob, useName+".gpx");

  return;
}
//............................................................................................................
async function makeCue()
{
    if(allPoints.length<=0){alert("You must have a track before you can create a GPX output file.");return;}
    
    var speed = document.getElementById("tcxSpeed").value;
    var units = document.getElementById("unitSystem").value;
    var routeName = document.getElementById("tcxName").value;
    if (units=="0")units = "imperial";
    else if (units=="1") units = "metric";
    var ApiHeaders =  {'Accept': 'application/json','Content-Type': 'application/json'};	    
    var data = {allPoints:allPoints,units:units,speed:speed};
    var url = `${protocol}//${hostname}:${port}/showDirections`;
    var theResp = await fetch(url,{method:'POST',body:JSON.stringify(data),headers:ApiHeaders});
    var theJson = await theResp.json();
        
    var OutText = theJson.html;
    var useName = theJson.name;
    var routeName = document.getElementById("tcxName").value.trim();
    if (routeName.length>0) useName = routeName;
    
    var blob = new Blob([OutText], {type: "text/plain;charset=utf-8"});
    saveAs(blob, useName+".html");

  return;
}
//..................................................................................................
async function makeGPX2()
{
    if(allPoints.length<=0){alert("You must have a track before you can create a GPX output file.");return;}
    
    var ApiHeaders =  {'Accept': 'application/json','Content-Type': 'application/json'};	    
    var data = {allPoints:allPoints};
    var url = `${protocol}//${hostname}:${port}/makeDenseGPX`;
    var theResp = await fetch(url,{method:'POST',body:JSON.stringify(data),headers:ApiHeaders});
    var theJson = await theResp.json();
    
    var OutText = theJson.gpx;
    var useName = theJson.name;
    var routeName = document.getElementById("tcxName").value.trim();
    if (routeName.length>0) useName = routeName;

    var blob = new Blob([OutText], {type: "text/plain;charset=utf-8"});
    saveAs(blob, useName+".gpx");
    

  return;
}
//....................................................................
async function makeTCX()
{

    if(allPoints.length<=0){alert("You must have a track before you can create a GPX output file.");return;}
    
    var ApiHeaders =  {'Accept': 'application/json','Content-Type': 'application/json'};	    
    var speed = document.getElementById("tcxSpeed").value;
    var advance = document.getElementById("tcxAdvance").value;
    var units = document.getElementById("unitSystem").value;
    var routeName = document.getElementById("tcxName").value;
    if (units=="0")units = "imperial";
    else if (units=="1") units = "metric";
    var data = {allPoints:allPoints,units:units,speed:speed,advance:advance,name:routeName};
    var url = `${protocol}//${hostname}:${port}/makeTCX`;
    var theResp = await fetch(url,{method:'POST',body:JSON.stringify(data),headers:ApiHeaders});
    var theJson = await theResp.json();
    
    var OutText = theJson.tcx;
    var useName = theJson.name;
    var routeName = document.getElementById("tcxName").value.trim();
    if (routeName.length>0) useName = routeName;

    var blob = new Blob([OutText], {type: "text/plain;charset=utf-8"});
    saveAs(blob, useName+".gpx");
    
  return;
  
}
//...............................................................................................

function makeKML()
{
  var OutText;
  var SPC = "  ";

  var opts = 2;
  
  if(opts==1)
    {
      var LFT = "&lt;";
      var RGT = "&gt;";
      var Break = "<br>";
    }
  else if (opts==2)
    {
      var LFT = "<";
      var RGT = ">";
      var Break = "\n";
    }

  OutText = "";
  //OutText += "<pre>";
  OutText += LFT + "?xml version=\"1.0\" ?" + RGT + Break;
  OutText += LFT + "kml xmlns=\"http://www.opengis.net/kml/2.2\"" + RGT + Break;
  OutText += SPC + LFT + "Document" + RGT + Break;

  //The route
  OutText += SPC + LFT + "Folder" + RGT + Break;
  OutText += SPC + LFT + "name" + RGT + "RouteLoops Route" + LFT + "/name" + RGT + Break;

  //Styles
  OutText += LFT + "Style id=\"BlueLine\"" + RGT + Break;
  OutText += LFT + "LineStyle" + RGT + LFT + "color" + RGT + "77ff0000" + LFT + "/color" + RGT + LFT + "width" + RGT + "20" + LFT + "/width" + RGT + LFT + "/LineStyle" + RGT + Break;
  OutText += LFT + "/Style" + RGT + Break;

  OutText += SPC + LFT + "Placemark" + RGT + Break;
  OutText += SPC + LFT + "name" + RGT + "RouteLoops Route" + LFT + "/name" + RGT + Break;
  OutText += LFT + "styleUrl" + RGT + "#BlueLine" + LFT + "/styleUrl" + RGT + Break;
  OutText += SPC + LFT + "description" + RGT + "The RouteLoops route" + LFT + "/description" + RGT + Break;
  OutText += SPC + SPC + LFT + "LineString" + RGT + Break;
  OutText += SPC+SPC+SPC+ LFT + "extrude" + RGT + "1" + LFT + "/extrude" + RGT + Break;
  OutText += SPC+SPC+SPC+ LFT + "tessellate" + RGT + "0" + LFT + "/tessellate" + RGT + Break;
  OutText += SPC+SPC+SPC+ LFT + "altitudeMode" + RGT + "relativeToGround" + LFT + "/altitudeMode" + RGT + Break;
  OutText += SPC + SPC + SPC + SPC + SPC + LFT + "coordinates" + RGT + Break;
  for(var j=0;j<currentRouteData.length;j++)
    {
      OutText += SPC+SPC+SPC+SPC+SPC+SPC + currentRouteData[j].lng + "," + currentRouteData[j].lat + "," + "1" + Break;
    }
  OutText += SPC+SPC+SPC+SPC+SPC+SPC + currentRouteData[0].lng + "," + currentRouteData[0].lat + "," + "1" + Break;
  OutText += SPC + SPC + SPC + SPC + SPC + LFT + "/coordinates" + RGT + Break;
  OutText += SPC + SPC + LFT + "/LineString" + RGT + Break;
  OutText += SPC + LFT + "/Placemark" + RGT + Break;
  OutText += SPC + LFT + "/Folder" + RGT + Break;

  OutText += SPC + LFT + "/Document" + RGT + Break;
  OutText += LFT + "/kml" + RGT + Break;
  //OutText += "</pre>" + Break;

  //generator.document.write(OutText);
  var currentTime = new Date();
  var year = currentTime.getFullYear();
  var month = currentTime.getMonth() + 1;
  var day = currentTime.getDate();
  var hour = currentTime.getHours();
  var minute = currentTime.getMinutes();
  var name = "RL-" + year + "-" + padZeros(month,2) + "-" + padZeros(day,2) + "-" + padZeros(hour,2) + padZeros(minute,2);
  if(document.getElementById("tcxName").value=="")name=name;
  else name = document.getElementById("tcxName").value;
  var blob = new Blob([OutText], {type: "text/plain;charset=utf-8"});
  saveAs(blob, name+".kml");
}
//........................................................................................................................
function showSteps(result) 
{
  // For each step, place a marker, and add the text to the marker's info window. Also attach the marker to an array so we
  // can keep track of it and remove it when calculating new  routes.
  var myRoute = result.routes[0].legs[0];    
  // First, clear out any existing markerArray from previous calculations.
  for (var i = 0; i < markerArray.length; i++) {
    markerArray[i].setMap(null);
  }

  //Locate a point before each direction where you write the direction information.  The 
  //point you want to find will be in the path[] array of the previous leg[].
  var offset = document.getElementById("tcxAdvance").value;
  if(document.getElementById("unitSystem").value==0) //This means Imperial units, so convert to meters
    offset *= 12*2.54/100;
  var Time = myRoute.duration.value;
  var Dist = myRoute.distance.value;
  var Velocity = Dist/Time; //in meters/second
  var lastTime;
  markerLabel.length = 0;
  markerArray.length = 0;
  markerPosition.length = 0;

  for (var i=0;i<myRoute.steps.length;i++)
    {
      //First, put course point warnings directly at the location of those turns, etc.
      latOffset = myRoute.steps[i].path[0].lat();
      lngOffset = myRoute.steps[i].path[0].lng();

      //Next put course point warnings in advance of the next location, if the user has requested it.
      if(offset>0 && i<myRoute.steps.length-1)
	{
	  var next = i+1;
	  //Find the first point in this leg which is <'offset' meters before the start of the next leg.
	  var latActual = myRoute.steps[next].start_point.lat();
	  var lngActual = myRoute.steps[next].start_point.lng();
	  var previous = next-1;
	  //If there is a leg with only 2 points, we know that the course point will HAVE to be on the first one.
	  if(myRoute.steps[previous].path.length==2)
	    {
	      var j = 0;
	      latOffset = myRoute.steps[previous].path[j].lat();
	      lngOffset = myRoute.steps[previous].path[j].lng();
	    }
	  else //you have to figure out which is the right point to use.
	    {
	      for (var j=0;j<myRoute.steps[previous].path.length;j++)
		{
		  var latOffset = myRoute.steps[previous].path[j].lat();
		  var lngOffset = myRoute.steps[previous].path[j].lng();
		  var sep = LatLngDist(latActual,lngActual,latOffset,lngOffset)*1000;
		  if(sep<offset)
		    {
		      if(j==myRoute.steps[previous].path.length-1)
			{
			  //alert("Writing the CP warning on the LAST point.");
			  j = myRoute.steps[previous].path.length-2; //move it back by at least 1 point, unless the user clearly wants it at the end.
			  latOffset = myRoute.steps[previous].path[j].lat();
			  lngOffset = myRoute.steps[previous].path[j].lng();
			  sep = LatLngDist(latActual,lngActual,latOffset,lngOffset)*1000;
			}
		      break;
		      }
		}
	      //Since sep is actually < offset, use either this point or the last one, whichever is closest to 'offset'.
	      if(j>0)
		{
		  var XlatOffset = myRoute.steps[previous].path[j-1].lat();
		  var XlngOffset = myRoute.steps[previous].path[j-1].lng();
		  var Xsep = LatLngDist(latActual,lngActual,XlatOffset,XlngOffset)*1000;
		  if(Math.abs(Xsep-offset) < Math.abs(sep-offset))
		    {
		      latOffset = XlatOffset;
		      lngOffset = XlngOffset;
		      j = j-1;
		    }
		}
	    }
	  // Now, since you are already putting the directions right at the corners, too, don't allow this part of the code to write
	  // at either the beginning, or end, of this path.  Overwriting 2 directions in the same place is not helpful, and Garmin 
	  // can't handle it at all.  Nothing appears, which is confusing.  So if you ever decide to remove the code where you write on
	  // the endpoints you will have to remove this check, but for now...
	  if(j!=myRoute.steps[previous].path-1)
	    {
	      var markTemp = new google.maps.LatLng(latOffset,lngOffset);
	      markerPosition.push(markTemp);
	      var marker = new google.maps.Marker({
		position: markTemp, 
		    map: map,
		    visible: false,  //DEBUG this on and off
		    draggable: true
		    });
	      attachInstructionText(marker, myRoute.steps[next].instructions);
	      markerLabel.push(myRoute.steps[next].instructions);
	      markerArray.push(marker);
	    }
	  
	  //A little added bonus.  If you are doing advance warnings and there is a point JUST BEFORE the last point, put a warning there.
	  if(j<myRoute.steps[previous].path.length-2  && myRoute.steps[previous].path.length>3)
	    {
	      j = myRoute.steps[previous].path.length-2;
	      latOffset = myRoute.steps[previous].path[j].lat();
	      lngOffset = myRoute.steps[previous].path[j].lng();
	      markTemp = new google.maps.LatLng(latOffset,lngOffset);
	      markerPosition.push(markTemp);
	      var marker = new google.maps.Marker({
		position: markTemp, 
		    map: map,
		    visible: false,  //DEBUG this on and off
		    draggable: true
		    });
	      attachInstructionText(marker, myRoute.steps[next].instructions);
	      markerLabel.push(myRoute.steps[next].instructions);
	      markerArray.push(marker);
	    }
	  
	}// end loop over whether or not you do advance warnings.
    }// end loop for creating the warnings, advance or not.
  
  
  buildDirections(result);
  
  return;
  
}
//.......................................................................................................
function reverseOrNew()
{
  // This function is used if the user changes the travelDirection parameter.  If there is no path yet, just get points and make route.
  // But if there IS a path, reverse the direction of the waypoints and the just recalculate the route.
  if(rlPoints.length==0)
    {
      getRLpoints();
      calcRoute();
    }
  else 
    {
      rlPoints.reverse();
      calcRoute();
    }
}
//........................................................................................
async function redrawOrNew(flag)
{
  // This function is used whenever you want to update things on the map without changing the route. If there is no path yet, just get points and make route..
  // But if there IS a path, load up the waypoints and then just recalculate the route.

  if(flag==-1)rlPoints.length=0;  //If you set the flag to -1, this will create a new route no matter what.

  if(rlPoints.length==0)
    {
      await getRLpoints();
      await calcRoute();
    }
  else 
    {
      await calcRoute();
    }

  return;
}
//..............................................................................................
function switchUnits()
{
    // This function is used whenever you want to switch the units from one to the other.
    if(rlPoints.length==0)
    {
	if(document.getElementById("unitSystem").value == 0)
	{
	    document.getElementById("inputUnits").innerHTML = "miles";
	    var temp = document.getElementById("length").value * 1000*100/2.54/12/5280;
	    document.getElementById("length").value = temp.toFixed(2);
	    document.getElementById("tcxUnits").innerHTML = "feet";
	    document.getElementById("tcxAdvance").value *= 100/2.54/12;
	    temp = document.getElementById("tcxSpeed").value * 1000*100/2.54/12/5280;
	    document.getElementById("tcxSpeed").value = temp.toFixed(2);
	    document.getElementById("tcxSpeedUnits").innerHTML = "mph";
        }
	else
	{
	    document.getElementById("inputUnits").innerHTML = "kilometers";
	    var temp = document.getElementById("length").value * 5280*12*2.54/100/1000;
	    document.getElementById("length").value = temp.toFixed(2);
	    document.getElementById("tcxUnits").innerHTML = "meters";
	    document.getElementById("tcxAdvance").value *= 12*2.54/100;
	    temp = document.getElementById("tcxSpeed").value * 5280*12*2.54/100/1000;
	    document.getElementById("tcxSpeed").value = temp.toFixed(2);
	    document.getElementById("tcxSpeedUnits").innerHTML = "kph";
	}
	//calcRoute();
    }
    else 
    {
	//redrawOrNew();
	if(document.getElementById("unitSystem").value == 0)
	{
	    document.getElementById("inputUnits").innerHTML = "miles";
	    var temp = document.getElementById("length").value * 1000*100/2.54/12/5280;
	    document.getElementById("length").value = temp.toFixed(2);
	    temp = document.getElementById("total_1").innerHTML.split(" ")[0] * 1000*100/2.54/12/5280;
	    document.getElementById("total_1").innerHTML = `${temp.toFixed(2)} miles`;
	    totalDistanceInCurrentUnits = temp;	    
	    document.getElementById("tcxUnits").innerHTML = "feet";
	    document.getElementById("tcxAdvance").value *= 100/2.54/12;
	    temp = document.getElementById("tcxSpeed").value * 1000*100/2.54/12/5280;
	    document.getElementById("tcxSpeed").value = temp.toFixed(2);
	    document.getElementById("tcxSpeedUnits").innerHTML = "mph";
        }
	else
	{
	    document.getElementById("inputUnits").innerHTML = "kilometers";
	    var temp = document.getElementById("length").value * 5280*12*2.54/100/1000;
	    document.getElementById("length").value = temp.toFixed(2);
	    temp = document.getElementById("total_1").innerHTML.split(" ")[0] * 5280*12*2.54/100/1000;
	    document.getElementById("total_1").innerHTML = `${temp.toFixed(2)} km`;
	    totalDistanceInCurrentUnits = temp;	    
	    document.getElementById("tcxUnits").innerHTML = "meters";
	    document.getElementById("tcxAdvance").value *= 12*2.54/100;
	    temp = document.getElementById("tcxSpeed").value * 5280*12*2.54/100/1000;
	    document.getElementById("tcxSpeed").value = temp.toFixed(2);
	    document.getElementById("tcxSpeedUnits").innerHTML = "kph";
	}
    }

    writeCookies();
    return;
}
//.................................................................................................
function autoFit()
{
    if(allPoints.length==0)return;  //There is no reason to be here, yet.

    var pathPoints = [];
    for (const point of allPoints) pathPoints.push(new L.LatLng(point.lat,point.lng));
    var pointPath = new L.Polyline(pathPoints, {color:'blue',weight:2,opacity: 1.0,smoothFactor: 1});
    //guidepointPath.addTo(map);    

    //Get a bounding box used to zoom the map to a more reasonable size.
    const RLBounds = pointPath.getBounds();
    map.fitBounds(RLBounds);
    
    return;
}

//.................................................................................................
function toggleAutoClean()
{
    if(DoClean) //You are cleaning.  Want to turn it off, and set the button to turn it on.
    {
	DoClean = false;
	document.getElementById("toggleClean").value="Turn AutoClean On";
	document.getElementById("toggleClean").className="butt3";
    }
    else if(!DoClean) //You are not cleaning.  Want to turn it on, set the button to turn it off.
    {
	DoClean = true;
	document.getElementById("toggleClean").value="Turn AutoClean Off";
	document.getElementById("toggleClean").className="butt1";
    }
    var CookieClean   = document.getElementById("toggleClean").value;
    createCookie("Clean",CookieClean);
    
}
//.................................................................................................
function dragNoDrag(path)
{
    if(path==0){//Lock it.
	directionsDisplay.setOptions({draggable:false});
    }
    else if(path==1){//Unlock it.
	directionsDisplay.setOptions({draggable:true});
    }

    else if(path==-1){//Switch it.
	var state = directionsDisplay.draggable;
	if(state){//currently draggable.  Make it not.
	    document.getElementById('routeDrag').value = "Route Locked. (not draggable)";
	    directionsDisplay.setOptions({draggable:false});
	}
	else{//Currently not draggable.  Make it so.
	    document.getElementById('routeDrag').value = "Route Unlocked. (draggable)";
	    directionsDisplay.setOptions({draggable:true});
	}
    }
	    

    return;
}
//..................................................................................
function toggleElevation()
{
    if(!ePlot) //You are not showing the elevation plot and you want to start
    {
	ePlot = true;
	document.getElementById("toggleButton").value="Turn Plot Off";
	document.getElementById("elevation_chart").style.visibility = "visible";
	document.getElementById("elevation_chart").style.display = "block";
	document.getElementById("ecButton").style.visibility = "visible";
	document.getElementById("ecButton").style.display = "block";
	// Actually generate the plot.
	drawElevationPlot();
    }
    else // You are showing it now, and you want to turn it off.
    {
	ePlot = false;
	document.getElementById("toggleButton").value="Turn Plot On";
	document.getElementById("elevation_chart").style.visibility = "hidden";
	document.getElementById("elevation_chart").style.display = "none";
	document.getElementById("ecButton").style.visibility = "hidden";
	document.getElementById("ecButton").style.display = "none";
    }
    
    return;
}
//..................................................................................
function toggleTraffic()
{
    if(!trafficLayer.getMap())  //not showing it, but you want to
    {
	rtTraffic = true;
	document.getElementById("toggleTraffic").value="Traffic Off";
	trafficLayer.setMap(map);
    }
    else // you are showing it, and want to stop
    {
	rtTraffic = false;
	document.getElementById("toggleTraffic").value="Traffic On";
	trafficLayer.setMap(null);
    }
    
    return;
}
//...................................................................................
function toggleFerries()
{
  if(document.getElementById("ferryButton").value==0)
    {
	allowFerries = false;
	redrawOrNew();
    }
  else
    {
	allowFerries = true;
	redrawOrNew();
    }
  return;
}
//.......................................................
function toggleMap()
{
    if(document.getElementById("toggleMap").value=="Bigger Map")
    {
	document.getElementById("middle").style.height="120%";
	document.getElementById("middle").style.width="150%";
	document.getElementById("toggleMap").value="Smaller Map";
	//document.getElementById("mapsize").style.top="35%";
	//document.getElementById("mapsize").style.left="73%";
	google.maps.event.trigger(map,'resize');
    }
  else
    {
	document.getElementById("middle").style.height="70%";
	document.getElementById("middle").style.width="100%";
	document.getElementById("toggleMap").value="Bigger Map";
	//document.getElementById("mapsize").style.top="30%";
	//document.getElementById("mapsize").style.left="44%";
	google.maps.event.trigger(map,'resize');
    }
}
//.........................................................
function drawElevationPlot()
{

  var allPoints = [];

  // Create a new chart in the elevation_chart DIV.
  chart = new google.visualization.ColumnChart(document.getElementById('elevation_chart'));

  var step = routeResult.routes[0].legs[0].steps.length;
  var countPoints = 0;
  for(var i=0;i<step;i++)
    {
      var path = routeResult.routes[0].legs[0].steps[i].path.length;
      for(var j=0;j<path;j++)
	{
	  if(i>0 && j==0)continue; //Do not write this point since it is also the end of the last leg.
	  var Lat = routeResult.routes[0].legs[0].steps[i].path[j].lat();
	  var Lng = routeResult.routes[0].legs[0].steps[i].path[j].lng();
	  allPoints[countPoints] = new google.maps.LatLng(Lat,Lng);
	  countPoints++;
	}
    }
  // Create a PathElevationRequest object using this array.
  // Ask for 256 samples along that path.
  //alert("Making an elevation request of " + allPoints.length + " points.");
  //There is a limitation on the elevation service from google, which says that in each query to the service you 
  //can have no more than 1024 requests.  So here we make a thinned out array, rather than using all of allPoints.
  var thinnedArray = [];
  var pointLimit = 250; // Set here the number of points you will pass over to google.
  var ratio = pointLimit/allPoints.length;
  if(ratio>1)ratio=1;
  var track = 0;
  var last = -1;
  for(var i=0;i<allPoints.length;i++)
    {
      track += ratio;
      if(Math.floor(track) > last)
	{
	  thinnedArray.push(allPoints[i]);
	  last = Math.floor(track);
	}
    }

  var pathRequest = {
    'path': thinnedArray,
    'samples': 256
  }
  // Initiate the path request.
  elevator.getElevationAlongPath(pathRequest, plotElevation);
}
//.......................................................................................................
function plotElevation(results, status) {
// Takes an array of ElevationResult objects
// and plots the elevation profile on a Visualization API ColumnChart.

  if (status == google.maps.ElevationStatus.OK) {
    elevations = results;

    // Extract the data from which to populate the chart.
    // Because the samples are equidistant, the 'Sample'
    // column here does double duty as distance along the
    // X axis.

    var units;
    if(document.getElementById("unitSystem").value == 0)units=0;
    else units = 1;
    elevDist.length = 0;

    var data = new google.visualization.DataTable();
    data.addColumn('string', 'Distance');
    data.addColumn('number', 'Elevation');
    for (var i = 0; i < results.length; i++) {
      var scaledDistance = (totalDistanceInCurrentUnits*i/results.length);
      elevDist.push(scaledDistance);
      data.addRow([scaledDistance.toFixed(1).toString(),elevations[i].elevation]);
    }

    // Draw the chart using the data within its DIV. 
    document.getElementById('elevation_chart').style.display = 'block';
    document.getElementById('ecButton').style.display = 'block';
    if(units==0)var tx = "Distance (mi)";
    else var tx = "Distance (km)";
    chart.draw(data, {
      width: 640,
	  title: 'Move the cursor over the elevation plot to see the location on the route',
	  height: 200,
	  legend: 'none',
	  titleY: 'Elevation (m)',
	  titleX: tx
      });

    // Every time the chart fires the "select" event, it should call your
    // myClickHandler() function.
    //google.visualization.events.addListener(chart, 'select', myClickHandler);
    google.visualization.events.addListener(chart, 'onmouseover', myMouseOverHandler);
    google.visualization.events.addListener(chart, 'onmouseout', myMouseOutHandler);
  }
  else
    {
      alert ("The Elevation Service did not return OK, for some reason.  Returned: " + status);
    }
}  
//...........................................................................................

function myClickHandler(){
  var selection = chart.getSelection();

  for (var i = 0; i < selection.length; i++) {
    var item = selection[i];
    //alert("Item " + i + " is " + item.row + " " + item.column);
    //alert("Location is " + elevations[item.row].location.toString());
    //placeMarker(elevations[item.row].location,elevations[item.row].elevation.toString());
    var marker = new google.maps.Marker({
      position: elevations[item.row].location, 
	  map: map
	  });
    if(document.getElementById("unitSystem").value == 0)
      var mText = "Elevation at distance " + elevDist[item.row].toFixed(1) + " miles is " + elevations[item.row].elevation.toFixed(1).toString() + " meters";
    else
      var mText = "Elevation at distance " + elevDist[item.row].toFixed(1) + " kilometers is " + elevations[item.row].elevation.toFixed(1).toString() + " meters";
    attachInstructionText(marker,mText);
  }
}

//...............................................................................................
function myMouseOverHandler(mE)
{
  //alert("event " + mE.row);

  if(document.getElementById("unitSystem").value == 0)
    {
      var Grade;
      if(mE.row>0)
	{
	  var x1 = elevDist[mE.row-1];
	  var x2 = elevDist[mE.row];
	  var y1 = elevations[mE.row-1].elevation;
	  var y2 = elevations[mE.row].elevation;
	  x1 *= 5280*12*2.54/100;
	  x2 *= 5280*12*2.54/100;
	  Grade = (y2-y1)/(x2-x1);
	}
      else Grade = 0;
      var mText = "Elevation at distance " + elevDist[mE.row].toFixed(1) + " miles is " + elevations[mE.row].elevation.toFixed(1).toString() + 
	" meters" + "\n" + "Grade at this point is about " + (Grade*100).toFixed(1) + "%";
    }
  else
    {
      var Grade;
      if(mE.row>0)
	{
	  var x1 = elevDist[mE.row-1];
	  var x2 = elevDist[mE.row];
	  var y1 = elevations[mE.row-1].elevation;
	  var y2 = elevations[mE.row].elevation;
	  x1 *= 1000;
	  x2 *= 1000;
	  Grade = (y2-y1)/(x2-x1);
	}
      else Grade = 0;
      var mText = "Elevation at distance " + elevDist[mE.row].toFixed(1) + " kilometers is " + elevations[mE.row].elevation.toFixed(1).toString() + 
	" meters" + "\n" + "Grade at this point is about " + (Grade*100).toFixed(1) + "%";
    }

  stepDisplay.setContent(mText);
  stepDisplay.setPosition(elevations[mE.row].location);
  stepDisplay.open(map);

  bikeMarker = new google.maps.Marker({
    position: elevations[mE.row].location, 
	map: map,
	icon: 'RLimages/OldBike2.png'
	});
  
}
//..................................................................................................
function myMouseOutHandler(mE)
{
  bikeMarker.setMap(null);
}
//..................................................................................................
function showDirectionFlag(index)
{
  var Text = routeResult.routes[0].legs[0].steps[index].instructions;
  var Location = routeResult.routes[0].legs[0].steps[index].start_location;
  stepDisplay.setContent(Text);
  stepDisplay.setPosition(Location);
  stepDisplay.open(map);
}
//..................................................................................................

function placeMileMarkers()
{

    var Dist;
    var LastDist;
    var WriteDist;
    var speed = parseFloat(document.getElementById("tcxSpeed").value);

    if(!showingMarkers)  //You are not showing them and you want to.
    {
	showingMarkers = true;
	document.getElementById("toggleMileMarkers").value="Turn distance markers off";

	// First, clear out any existing distance markers from previous maps.
	for (var i = 0; i < mileMarkers.length; i++) {
	    map.removeLayer(mileMarkers[i].marker);	  
	}

	{
	    //Get the current time
	    var now = new Date();
	    var month = now.getMonth();
	    month++;
	    var date = now.getDate();
	    var hour = now.getHours();
	    var minute = now.getMinutes();
	    var offset = now.getTimezoneOffset();
	}
	//Set the true ride start time, to get appropriate weather information.
	//Let the user say what time he wants to start.  
	//This can be out of the range of the forecast, so you'll have to capture that, but for now just do it.
	/*
	var text = month + "/" + date + "," + hour + ":" + minute;
	var startDT = prompt("Choose your starting time for this ride in this format: MM/DD,HH:MM" , text);
	var startD  = startDT.split(",")[0];
	var startMonth = startD.split("/")[0];
	startMonth--;
	var startDate = startD.split("/")[1];
	var startT  = startDT.split(",")[1];
	var startHour = startT.split(":")[0];
	var startMinute = startT.split(":")[1];
	var startTimestamp = new Date(now.getFullYear(), startMonth, startDate, startHour, startMinute, 0, 0);
	rideStart = new Date(startTimestamp);
	*/

	var numMM = Math.floor(totalDistanceInCurrentUnits);
	//alert("The number of distance markers will be " + numMM);
	if(numMM>=1)var next = 1;
	var step = allPoints.length;
	for(var i=0;i<step;i++)
	{
	    var Lat = allPoints[i].lat;
	    var Lng = allPoints[i].lng;
	    if(i==0)
	    {
		Dist = 0;
	    }
	    else
	    {
		var pathlength = LatLngDist(Lat,Lng,Last.lat,Last.lng) * 1000;
		if(document.getElementById("unitSystem").value == 0)
		{
		    pathlength *= 100/2.54/12/5280;
		}
		else if (document.getElementById("unitSystem").value == 1)
		{
		    pathlength /= 1000;
		}
		Dist += pathlength;
	    }
	    if(Dist>=next)
	    {
		//Use either this one, or the last one.
		if(Math.abs(LastDist-next)<Math.abs(Dist-next))
		{
		    WriteLat = Last.lat;
		    WriteLng = Last.lng;
		    WriteDist = LastDist;
		}
		else
		{
		    WriteLat = Lat;
		    WriteLng = Lng;
		    WriteDist = Dist;
		}
		//alert("Found the Lat Lng for the marker at " + next);
		var markerPosition = {lat:WriteLat, lng:WriteLng};
		if(next<=100)
		{
		    var thisIcon = L.icon({iconUrl:`./RLimages/icong${next}.png`});
		    var marker   = L.marker([markerPosition.lat, markerPosition.lng], {icon: thisIcon,draggable:true,title:next}).addTo(map);			
		}
		else
		{
		    var thisIcon = L.icon({iconUrl:`./RLimages/icong.png`});
		    var marker   = L.marker([markerPosition.lat, markerPosition.lng], {icon: thisIcon,draggable:true,title:next}).addTo(map);			
		}
		var flagText = "";
		var secondsToPoint = WriteDist/speed * 60 *60;
		var atTime = new Date(rideStart);
		atTime.setSeconds(atTime.getSeconds() + secondsToPoint);		  
		/*
		if(document.getElementById("unitSystem").value == 0)flagText = next + " mile marker" + "  ("+WriteDist.toFixed(2) + " miles." +")";
		if(document.getElementById("unitSystem").value == 1)flagText = next + " kilometer marker" + "  ("+WriteDist.toFixed(2) + " km."+")";
		flagText += "<br/>";
		flagText += "Estimated time at this point, " + atTime;
		attachInstructionText(marker,flagText);
		*/
		mileMarkers[next-1] = {marker:marker, timeStamp:atTime, text:flagText};
		next++;
	    }
	    var Last = {lat:Lat, lng:Lng};
	    var LastDist = Dist;
	}
    }
    else if(showingMarkers) //You are showing them, and you want to stop.
    {
	showingMarkers = false;
	document.getElementById("toggleMileMarkers").value="Turn distance markers on";
	
	// Clear the distance markers.
	for (var i = 0; i < mileMarkers.length; i++) {
	    map.removeLayer(mileMarkers[i].marker);
	}
    }
    
    
    return;
}
//......................................................................................................
function pathPoint(lat,lng,time){
    this.lat = lat;
    this.lng = lng;
    this.time = time;
}
//......................................................................................................
function routeData(lat,lng,dist,height,pitch,peak,trough,instructions,write){
    this.lat = lat;  //degrees
    this.lng = lng;  //degrees
    this.dist = dist; //meters
    this.height = height;   //meters
    this.pitch = pitch;   //number -- this is the slope at any given point
    this.peak = peak;
    this.trough = trough;
    this.instructions = instructions;
    this.write = write;
}
//......................................................................................................
function storeRouteData()
{
  currentRouteData.length = 0;
  var thisRoute = routeResult.routes[0].legs[0];
  var step = thisRoute.steps.length;
  for(var i=0;i<step;i++)
    {
      var path = thisRoute.steps[i].path.length;
      for(var j=0;j<path;j++)
	{
	  var txt = new String();
	  if(j==0)
	    {
	      txt = thisRoute.steps[i].instructions;
	    }
	  if(i>0 && j==0)
	    {
	      var cRDlen = currentRouteData.length;
	      currentRouteData[cRDlen-1].instructions = txt;
	      continue; //Do not write a new point since it is also the end of the last leg.  Put the instructions in that location already.
	    }
	  var Lat = thisRoute.steps[i].path[j].lat();
	  var Lng = thisRoute.steps[i].path[j].lng();
	  var temp = new routeData(Lat,Lng,0,0,0,false,false,txt,false);
	  currentRouteData.push(temp);
	}
    }


  currentRouteData[0].dist = 0;
  var dist = 0;
  for(var i=0;i<currentRouteData.length-1;i++)
    {
      var j = i+1;
      var distMeters = LatLngDist(currentRouteData[i].lat,currentRouteData[i].lng,currentRouteData[j].lat,currentRouteData[j].lng) *1000;
      dist += distMeters;
      currentRouteData[j].dist = dist;
    }

  //For debugging of the currentRouteData array
  for(var i=0;i<currentRouteData.length-1;i++)
    {
      if(currentRouteData[i].instructions.length>0)
	{
	  var turnLoc = new google.maps.LatLng(currentRouteData[i].lat,currentRouteData[i].lng);
	  var turnTxt = currentRouteData[i].instructions;
	  var turnMarker = new google.maps.Marker({
	    position: turnLoc,
		map: map,
		draggable: true,
		visible: false,  //DEBUG this on and off
		title: turnTxt
		});
	}
    }
  //End debugging
  makePermalink();
  createSpacedPath();

  return;

}
//......................................................................................................
function getElevations()
{
  if(Country!= "United States")
    {
      alert("You are not in the United States.");
      document.getElementById("Climb").style.color = "black";
      document.getElementById("Grade").style.color = "black";
      document.getElementById("Climb").innerHTML = "Outside";
      document.getElementById("Grade").innerHTML = "US";
      return;
    }
  
  document.getElementById("Climb").style.color = "black";
  document.getElementById("Grade").style.color = "black";
  document.getElementById("Climb").innerHTML = "...";
  document.getElementById("Grade").innerHTML = "...";
  
  $('body').append('<div id="progress">Profiling...</div>');
  
  retrieved = 0;
  //getSingleElevation(0);
  getMultipleElevations(0);

  return;
}
      
//......................................................................................................
function getSingleElevation(i)
{
  //var URL = "http://www.routeloops.com/altitude.php";
  //var URL = "https://maps.googleapis.com/maps/api/elevation/json?locations=";

  var Lat = useThis[i].lat;
  var Lng = useThis[i].lng;
  URL += Lat + "," + Lng;
  //URL += "&key=AIzaSyBmux0aOJvsLD3ldCgj1k69X9nDYF9Igcs";

  /*/
  // === call the altitude proxy server ===
  var html = $.ajax({
    url: URL,
	async: true,
	dataType: 'html',
	success: function(result)
      {
	var istart = result.indexOf("double>");
	istart += 7;
	var iend = result.indexOf("</double");
	iend -= 0;
	alt = result.substring(istart,iend);
	useThis[i].height = parseFloat(alt);
	//alert("OK! Got response for " + i + "with URL " + URL + " and it is " + result + " which is alt " + alt);
	retrieved++;
	if(retrieved==useThis.length)
	  {
	    //alert("You have them all");
	    $('#progress').remove();
	    profileRoute();
	  }
      }
    }).responseText;
    //*/

    /*// Only server side
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
	if(xhttp.readyState == 4 && xhttp.status == 200) {
	    alert(JSON.stringify(xhttp));
	}
	else{
	    alert(JSON.stringify(xhttp));
	}
    };

    xhttp.open('GET',URL,true);
    xhttp.send(null);
    //*/
	    
    var LL = new google.maps.LatLng(useThis[i].lat,useThis[i].lng);
    var locations = []; locations.push(LL); var positionalRequest = {'locations': locations};

    elevator.getElevationForLocations(positionalRequest,function(results,status){
	if(status==google.maps.ElevationStatus.OK)
	{
	    if(results[0]) useThis[i].height = parseFloat(results[0].elevation);
	    else           useThis[i].height = "Height Unknown";
	}
	else               useThis[i].height = "Height Unknown";

	i++;
	if(i<useThis.length){
	    if(i%100 == 0){
		$('#progress').remove();
		$('body').append('<div id="progress">Profiling...'+i+'/'+useThis.length+'</div>');
	    }
	    setTimeout(function(){getSingleElevation(i);} , 50);
	}
	else{
	    $('#progress').remove();
	    profileRoute();
	}
    });


  return;
}
//......................................................................................................
function getMultipleElevations(i)
{

    var locations = []; 

    var start = i;
    var end = start + 250;
    end = Math.min(end,useThis.length);

    for(var j=start;j<end;j++){
	var Lat = useThis[j].lat;
	var Lng = useThis[j].lng;   
	var LL = new google.maps.LatLng(Lat,Lng);
	locations.push(LL); 
    }

    var positionalRequest = {'locations': locations};
    elevator.getElevationForLocations(positionalRequest,function(results,status){
	if(status==google.maps.ElevationStatus.OK)
	{
	    if(results.length>0)
		for(var r=0;r<results.length;r++){
		    var j = start + r;
		    useThis[j].height = parseFloat(results[r].elevation);
		}
	    else 
		for(var j=start;j<end;j++)useThis[j].height = "Height Unknown";
	}
	else
	    for(var j=start;j<end;j++)useThis[j].height = "Height Unknown";

	i = end;
	if(i<useThis.length){
	    $('#progress').remove();
	    $('body').append('<div id="progress">Profiling...'+i+'/'+useThis.length+'</div>');
	    setTimeout(function(){getMultipleElevations(i);} , 50);
	}
	else{
	    $('#progress').remove();
	    profileRoute();
	}
    });


  return;
}
//......................................................................................................
function profileRoute()
{

  var Profile = new String();
  for(var i=0;i<useThis.length;i++)
    {
      Profile += useThis[i].dist + "\n";
    }
  //alert(Profile);

  var Profile = new String();
  for(var i=0;i<useThis.length;i++)
    {
	Profile += useThis[i].height + "\n";
    }
  //alert(Profile);

  //Make a smoothed version of the elevation profile to remove spikes.
  var runAve = 7;
  var istart;
  var iend;
  var aveArray = [];
  aveArray.length = 0;
  for(i=0; i<useThis.length; i++)
    {
      //Trivial case, but might as well handle it.
      if(useThis.length<runAve)
	{
	  istart = 0;
	  iend = useThis.length-1;
	  runAve = iend - istart + 1;
	}
      else
	{
	  //For every point, find runAve points that you can use to make an average
	  istart = i - Math.floor(runAve/2);
	  iend = istart + runAve -1;
	  while(istart<0)
	    {
	      istart++;
	      iend++;
	    }
	  while(iend>useThis.length-1)
	    {
	      istart--;
	      iend--;
	    }
	  //OK, so you have the starting and ending positions
	    var Average=0;
	    var count = 0;
	    for(var j=istart; j<iend+1; j++)
	    {
		if(!isNaN(useThis[j].height)){
		    Average += useThis[j].height;
		    count++;
		}
	    }
	    if(count>0)
		Average /= count;
	    else
		Average = 0;
	    aveArray.push(Average);
	}
    }

  var Profile = new String();
  for(var i=0;i<aveArray.length;i++)
    {
      Profile += aveArray[i] + "\n";
    }
  //alert(Profile);


  var averageElevation = 0;
  var maxElevation = 0;
  var minElevation = 1000000;
  var pitch = 0;
  var maxPitch = -100; var maxPindex=0;
  var minPitch = 0;
  var countPeaks = 0;
  var countTroughs = 0;
  var delta = 2;

  for(var i=0;i<useThis.length;i++)
    {
      //Average
      averageElevation += aveArray[i];

      //Max and Min
      maxElevation = Math.max(maxElevation,aveArray[i]);
      minElevation = Math.min(minElevation,aveArray[i]);

      var minDist = 30;
      //Pitch.  For the pitch calculation, DO NOT use a calculation over a horizontal distance of <minDist meters.
      if(i<useThis.length-1)
	{
	  var distMeters = 0;
	  var j = i;
	  while(distMeters<minDist)
	    {
	      j++;
	      if(j>useThis.length-1)break;
	      distMeters = useThis[j].dist-useThis[i].dist;
	    }
	  if(distMeters>=minDist)
	    pitch = (useThis[j].height-useThis[i].height)/distMeters;
	  else
	    pitch = 0;
	  //alert("Distance is " + distMeters + " and pitch is " + pitch*100);
	  if(isNaN(pitch))pitch=0;
	  useThis[i].pitch = pitch;
	}
      else if(i==useThis.length-1)
	{
	  useThis[i].pitch = useThis[i-1].pitch;
	}
      if(useThis[i].pitch>maxPitch)maxPindex=i;
      maxPitch = Math.max(maxPitch,useThis[i].pitch);
      minPitch = Math.min(minPitch,useThis[i].pitch);

      //Peaks and Troughs
      if(i>0 && i<useThis.length-1)
	{
	  var h = i-1;
	  var j = i+1;
	  if(aveArray[i]-aveArray[h]>delta && aveArray[i]-aveArray[j]>delta)
	    useThis[i].peak = true;
	  if(aveArray[h]-aveArray[i]>delta && aveArray[j]-aveArray[i]>delta)
	    useThis[i].trough = true;
	}
      if(useThis[i].peak)countPeaks++;
      if(useThis[i].trough)countTroughs++;
    }

    averageElevation /= useThis.length;
    //alert("The average height of this route is " + averageElevation + " meters.");
    //alert("The route goes between " + minElevation + " and " + maxElevation + " meters.");
    //alert("The pitch goes between " + minPitch*100+"%" + " and " + maxPitch*100+"%");
    //alert("The maximum pitch occurs at distance " + useThis[maxPindex].dist/1000 + " km.");
    //alert("There are " + countPeaks+ " peaks" + " and " + countTroughs +" troughs.");
    
    //Show the steepest spot.
    if(pitchMarker)pitchMarker.setMap(null); 
    var location = new google.maps.LatLng(useThis[maxPindex].lat,useThis[maxPindex].lng);
    pitchMarker = new google.maps.Marker({
        position: location, 
        map: map,
	icon: 'RLimages/steep.png',
	title: "Steepest Climb"
    });


    var ClimbRange = maxElevation - minElevation;
    document.getElementById("Climb").style.color = "red";
    document.getElementById("Grade").style.color = "red";
    if(ClimbRange>0 && ClimbRange<20)
	document.getElementById("Climb").innerHTML = "Easy(" + ClimbRange.toFixed(0) +"m)";
    if(ClimbRange>20 && ClimbRange<100)
      document.getElementById("Climb").innerHTML = "Ave(" + ClimbRange.toFixed(0) +"m)";
    if(ClimbRange>100 && ClimbRange<20000)
      document.getElementById("Climb").innerHTML = "Hard(" + ClimbRange.toFixed(0) +"m)";
    
    if(maxPitch*100>0 && maxPitch*100<7)
      document.getElementById("Grade").innerHTML = "Easy(" + (maxPitch*100).toFixed(1) +"%)";
    if(maxPitch*100>7 && maxPitch*100<12)
      document.getElementById("Grade").innerHTML = "Ave(" + (maxPitch*100).toFixed(1) +"%)";
    if(maxPitch*100>12 && maxPitch*100<500)
      document.getElementById("Grade").innerHTML = "Hard(" + (maxPitch*100).toFixed(1) +"%)";

    //alert("Climb range = " + ClimbRange + " Pitch = " + maxPitch*100 +"%" + " at " + useThis[maxPindex].dist/1000 + " km.");
}
//......................................................................................................

function attachInstructionText(marker, text) {
  google.maps.event.addListener(marker, 'click', function() {
    stepDisplay.setContent(text);
    stepDisplay.open(map, marker);
  });
  google.maps.event.addListener(marker, 'mouseover', function() {
    stepDisplay.setContent(text);
    stepDisplay.open(map, marker);
  });

  return;
}
//................................................
function useImport()
{
  //alert("Now in useImport, pointArray entries : " + pointArray.length);

  //Set the base location:
  var baseL;
  baseL = pointArray[0].lat.toString();
  baseL = baseL + ",";
  baseL = baseL + pointArray[0].lng.toString();
  //alert("Base is " + document.getElementById("address").value);
  //alert("Moving base to baseL: " + baseL);
  document.getElementById("address").value = baseL;
  createBaseMarker();
  codeAddress();
  baseSet = true;

  //Use the points just read to create some waypoints to go over to Google.
  var polyline = [];
  importedPolyline.length = 0;
  var TotalLength;
  var CumDist = [];
  var nL = pointArray.length;
  for (var j=0;j<nL;j++)
    {
      var LL = new google.maps.LatLng(pointArray[j].lat,pointArray[j].lng);
      polyline.push(LL);
      importedPolyline.push(LL);
    }

  TotalLength = 0;
  CumDist.push(TotalLength);
  for(var i=1;i<polyline.length;i++)
    {
      var dist = LatLngDist(polyline[i-1].lat(),polyline[i-1].lng(),polyline[i].lat(),polyline[i].lng());
      TotalLength += dist;
      CumDist.push(TotalLength);
    }

  var nPoints = 4; // Default to this for this case.
  var chunk = TotalLength/(nPoints+0.99); //The length of a segment from waypoint to waypoint.  Make is just SLIGHTLY longer than 1/(nPoints+1) to
                                            //avoid picking up the last point as a waypoint.
  rlPoints.length = 0;
  var point = 1;
  for(var i=0;i<polyline.length;i++)
    {
      if(CumDist[i] >= point*chunk)
	{
	  rlPoints.push(polyline[i]);
	  point++;
	}
    }
  
  if(travelDirection==0)//Clockwise
    // do nothing
    var i=0;
  else
    rlPoints.reverse();
  
  //alert("The total length of this route is " + TotalLength);
  
  if(document.getElementById("unitSystem").value == 0)
    document.getElementById("length").value = (TotalLength*1000*100/2.54/12/5280).toFixed(2);
  else if(document.getElementById("unitSystem").value == 1)
    document.getElementById("length").value = TotalLength.toFixed(2);
  
  alert("Rainbow line -- your imported route. (red>orange>green>violet\nBlue line -- your current RouteLoop.\nYou can drag the RouteLoop to match the imported route as closely as desired.");
  
  drawTrack();
  return;
}
//.................................................
function drawTrack()
{
  // If you have imported this data from some track, draw that track on the map as well.
  importedTracks.length=0;
  if(importedPolyline.length>0)
    {
      var chunk = Math.floor(importedPolyline.length/4);
      var iP1 = []; iP1.length = 0; for(var i=0*chunk;i<1*chunk;i++)iP1.push(importedPolyline[i]);
      var iP2 = []; iP2.length = 0; for(var i=1*chunk;i<2*chunk;i++)iP2.push(importedPolyline[i]);
      var iP3 = []; iP3.length = 0; for(var i=2*chunk;i<3*chunk;i++)iP3.push(importedPolyline[i]);
      var iP4 = []; iP4.length = 0; for(var i=3*chunk;i<importedPolyline.length;i++)iP4.push(importedPolyline[i]);
      importedTrack1 = new google.maps.Polyline({
	    strokeColor: "#FF0000",
	    strokeOpacity: 0.5,
	    strokeWeight: 10,
	    path: iP1
	    });
      importedTrack1.setMap(map);
      importedTracks.push(importedTrack1);
      importedTrack2 = new google.maps.Polyline({
	    strokeColor: "#FFAD00",
	    strokeOpacity: 0.5,
	    strokeWeight: 10,
	    path: iP2
	    });
      importedTrack2.setMap(map);
      importedTracks.push(importedTrack2);
      importedTrack3 = new google.maps.Polyline({
	    strokeColor: "#06FF00",
	    strokeOpacity: 0.5,
	    strokeWeight: 10,
	    path: iP3
	    });
      importedTrack3.setMap(map);
      importedTracks.push(importedTrack3);
      importedTrack4 = new google.maps.Polyline({
	    strokeColor: "#B400FF",
	    strokeOpacity: 0.5,
	    strokeWeight: 10,
	    path: iP4
	    });
      importedTrack4.setMap(map);
      importedTracks.push(importedTrack4);

      calcRoute();
    }
  return;
}
//.................................................
function clearTrack()
{
  for(var i=0;i<importedTracks.length;i++)
    if(importedTracks[i])importedTracks[i].setMap(null);
  return;
}
//............................................................
function parseText(textStuff)
{
  var textStuff;
  pointArray.length = 0;
  
  var trackPos = textStuff.indexOf("<trkpt");
  if(trackPos>0)
    {
      //alert("This is a <trkpt> file");
      //alert("First trackpoint is at " + trackPos);
      var point = trackPos + 1;
      pointArray.length = 0;
      while(point>0)
	{
	  point = trackPos + 1;
	  
	  //Get the lat
	  var latStartPos = textStuff.indexOf("lat",trackPos+1);
	  //alert("Lat appears at " + latStartPos);
	  latStartPos = textStuff.indexOf("\"",latStartPos+1);
	  //alert("The quote appears at " + latStartPos);
	  var latEndPos = textStuff.indexOf("\"",latStartPos+1);
	  //alert("The end quote appears at " + latEndPos);
	  var holdLat = textStuff.slice(latStartPos+1,latEndPos);
	  //alert("holdLat = " + holdLat);
	  var Lat = parseFloat(holdLat);
	  //alert("The latitude would appear to be " + Lat);
	  
	  //Get the lon
	  var lonStartPos = textStuff.indexOf("lon",trackPos+1);
	  //alert("Lon appears at " + lonStartPos);
	  lonStartPos = textStuff.indexOf("\"",lonStartPos+1);
	  //alert("The quote appears at " + lonStartPos);
	  var lonEndPos = textStuff.indexOf("\"",lonStartPos+1);
	  //alert("The end quote appears at " + lonEndPos);
	  var holdLon = textStuff.slice(lonStartPos+1,lonEndPos);
	  //alert("holdLon = " + holdLon);
	  var Lon = parseFloat(holdLon);
	  //alert("The longitude would appear to be " + Lon);
	  
	  //alert("Lat, Lon = " + Lat + "," + Lon);
	  pointArray.push(new LatLng(Lat,Lon));
	  trackPos = textStuff.indexOf("<trkpt",point);
	  //alert("Next trackpoint is at " + trackPos);
	  point = trackPos + 1;
	}
      //alert("Found this many points: " + pointArray.length);
      //alert("Here's the array >> " + pointArray[0].lat + "," + pointArray[0].lng);
    }

  var trackPos = textStuff.indexOf("<rtept");
  if(trackPos>0)
    {
      //alert("This is a <rtept> file");
      //alert("First trackpoint is at " + trackPos);
      var point = trackPos + 1;
      pointArray.length = 0;
      while(point>0)
	{
	  point = trackPos + 1;
	  
	  //Get the lat
	  var latStartPos = textStuff.indexOf("lat",trackPos+1);
	  //alert("Lat appears at " + latStartPos);
	  latStartPos = textStuff.indexOf("\"",latStartPos+1);
	  //alert("The quote appears at " + latStartPos);
	  var latEndPos = textStuff.indexOf("\"",latStartPos+1);
	  //alert("The end quote appears at " + latEndPos);
	  var holdLat = textStuff.slice(latStartPos+1,latEndPos);
	  //alert("holdLat = " + holdLat);
	  var Lat = parseFloat(holdLat);
	  //alert("The latitude would appear to be " + Lat);
	  
	  //Get the lon
	  var lonStartPos = textStuff.indexOf("lon",trackPos+1);
	  //alert("Lon appears at " + lonStartPos);
	  lonStartPos = textStuff.indexOf("\"",lonStartPos+1);
	  //alert("The quote appears at " + lonStartPos);
	  var lonEndPos = textStuff.indexOf("\"",lonStartPos+1);
	  //alert("The end quote appears at " + lonEndPos);
	  var holdLon = textStuff.slice(lonStartPos+1,lonEndPos);
	  //alert("holdLon = " + holdLon);
	  var Lon = parseFloat(holdLon);
	  //alert("The longitude would appear to be " + Lon);
	  
	  //alert("Lat, Lon = " + Lat + "," + Lon);
	  pointArray.push(new LatLng(Lat,Lon));
	  trackPos = textStuff.indexOf("<rtept",point);
	  //alert("Next routepoint is at " + trackPos);
	  point = trackPos + 1;
	}
      //alert("Found this many points: " + pointArray.length);
      //alert("Here's the array >> " + pointArray[0].lat + "," + pointArray[0].lng);
    }

  var trackPos = textStuff.indexOf("<Trackpoint>");
  if(trackPos>0)
    {
      //alert("This is a <Trackpoint> file");
      //alert("First trackpoint is at " + trackPos);
      var point = trackPos + 1;
      pointArray.length = 0;
      while(point>0)
	{
	  point = trackPos + 1;
	  
	  //Get the lat
	  var latStartPos = textStuff.indexOf("LatitudeDegrees",trackPos+1);
	  //alert("Lat appears at " + latStartPos);
	  latStartPos = textStuff.indexOf(">",latStartPos+1);
	  //alert("The quote appears at " + latStartPos);
	  var latEndPos = textStuff.indexOf("<",latStartPos+1);
	  //alert("The end quote appears at " + latEndPos);
	  var holdLat = textStuff.slice(latStartPos+1,latEndPos);
	  //alert("holdLat = " + holdLat);
	  var Lat = parseFloat(holdLat);
	  //alert("The latitude would appear to be " + Lat);
	  
	  //Get the lon
	  var lonStartPos = textStuff.indexOf("LongitudeDegrees",trackPos+1);
	  //alert("Lon appears at " + lonStartPos);
	  lonStartPos = textStuff.indexOf(">",lonStartPos+1);
	  //alert("The quote appears at " + lonStartPos);
	  var lonEndPos = textStuff.indexOf("<",lonStartPos+1);
	  //alert("The end quote appears at " + lonEndPos);
	  var holdLon = textStuff.slice(lonStartPos+1,lonEndPos);
	  //alert("holdLon = " + holdLon);
	  var Lon = parseFloat(holdLon);
	  //alert("The longitude would appear to be " + Lon);
	  
	  //alert("Lat, Lon = " + Lat + "," + Lon);
	  pointArray.push(new LatLng(Lat,Lon));
	  trackPos = textStuff.indexOf("<Trackpoint>",point);
	  //alert("Next trackpoint is at " + trackPos);
	  point = trackPos + 1;
	}
      //alert("Found this many points: " + pointArray.length);
      //alert("Here's the array >> " + pointArray[0].lat + "," + pointArray[0].lng);
    }

  if(pointArray.length>1)
    {
      //alert("Import of " + pointArray.length + " points successful.");
      useImport();
    }
  else if(pointArray.length<1)
    {
      alert("Import of only " + pointArray.length + " points.  Not enough for a route.");
    }

  return;
}
//.................................................
function makePermalink()
{
  var currentURL = location.href;
  var permalink;

  //Create a permalink using the current route.  All that is really needed to reproduce this route are the base location, 
  //the number of waypoints, the waypoints themselves, and the travel mode.
  var protocol = location.protocol;
  var host = location.host;
  var path = location.pathname;
  var extra;
  var wptString;

  wptString = "numWpts=" + routeResult.routes[0].legs[0].via_waypoint.length + "&";
  for(var i=0;i<routeResult.routes[0].legs[0].via_waypoint.length;i++)
    wptString = wptString + "wpt[" + i + "]=" + routeResult.routes[0].legs[0].via_waypoint[i].location.lat() + 
                                          ":" + routeResult.routes[0].legs[0].via_waypoint[i].location.lng() +"&";
  extra = "?Base="+BaseLocation.lat()+":"+BaseLocation.lng()+"&"+wptString;
  extra = extra + "tM=" + travelMode;
  extra = extra + "&len=" + document.getElementById("length").value;
  extra = extra + "&unitS=" + document.getElementById("unitSystem").value;
  extra = extra + "&doClean=" + DoClean;

  permalink = protocol+"//"+host+path + extra;
  document.getElementById("permalink").href = permalink;

  return;
}
//.........................................................................................................
function writeCookies()
{
  //Write cookies.  
  var CookieAddress = document.getElementById("address").value;
  var CookieLength  = document.getElementById("length").value;
  var CookieTM      = document.getElementById("travelMode").value;
  var CookieTD      = document.getElementById("travelDirection").value;
  var CookieUS      = document.getElementById("unitSystem").value;
  var CookieClean   = document.getElementById("toggleClean").value;
  createCookie("address",CookieAddress);
  createCookie("length",CookieLength);
  createCookie("TM",CookieTM);
  createCookie("TD",CookieTD);
  createCookie("US",CookieUS);
  createCookie("Clean",CookieClean);
  //alert("Address Cookie! " + readCookie("address"));
  //alert("Length Cookie! " + readCookie("length"));
  //alert("TM Cookie! " + readCookie("TM"));
  //alert("TD Cookie! " + readCookie("TD"));
  //alert("US Cookie! " + readCookie("US"));
  //alert("Clean Cookie! " + readCookie("Clean"));
  //Done with cookies
  return;
}
//..............................................................................................
function storeURL()
{
  // This is the same as the permalink thing above, but just make the string.  Don't do anything with it.
  var storedURL;
  var protocol = location.protocol;
  var host = location.host;
  var path = location.pathname;
  var extra;
  var wptString;

  wptString = "numWpts=" + routeResult.routes[0].legs[0].via_waypoint.length + "&";
  for(var i=0;i<routeResult.routes[0].legs[0].via_waypoint.length;i++)
    wptString = wptString + "wpt[" + i + "]=" + routeResult.routes[0].legs[0].via_waypoint[i].location.lat() + 
                                          ":" + routeResult.routes[0].legs[0].via_waypoint[i].location.lng() +"&";
  extra = "?Base="+BaseLocation.lat()+":"+BaseLocation.lng()+"&"+wptString;
  extra = extra + "tM=" + travelMode;
  extra = extra + "&len=" + document.getElementById("length").value;
  extra = extra + "&unitS=" + document.getElementById("unitSystem").value;


  storedURL = protocol+"//"+host+path + extra;

  return storedURL;
}

//.................................................................................................
function parseUrl(currentURL)
{

    var returnStatus = new Boolean();
    var urlInputsName = [];
    var urlInputsValue = [];
    var p1,p2,val;
    
    returnStatus = false;

    // Add a section to see if we have a URL from an embedded link (maplet, gadget, whatever).
    haveEmbedded = false;
    p1 = currentURL.indexOf("URLformat");
    if(p1>0)
    {
	//We have a format tag, so keep going
	p1 = currentURL.indexOf("=",p1)+1;
	p2 = currentURL.indexOf("&",p1);
	val = currentURL.substring(p1,p2);
	if(val=="embed")
	{
	    p1 = currentURL.indexOf("&",p2)+1;
	    p2 = currentURL.indexOf("=",p1)+1;
	    val = currentURL.substring(p1,p2);
	    if(val=="Base=")
	    {
		p1 = p2;
		p2 = currentURL.indexOf("&",p1);
		val = currentURL.substring(p1,p2);
		var Eaddress = val.replace(/%20/g," ");
	    }
	    else return;
	    p1 = p2+1;
	    p2 = currentURL.indexOf("=",p1)+1;
	    val = currentURL.substring(p1,p2);
	    if(val=="len=")
	    {
		p1 = p2;
		p2 = currentURL.length;
		val = currentURL.substring(p1,p2);
		var Elength = parseFloat(val);
		haveEmbedded = true;
		document.getElementById("address").value = Eaddress;
		codeAddress();
		document.getElementById("length").value = Elength.toFixed(2);
		return;
	    }
	    else return;
	}
	else return; //This shouldn't happen, so just get out.
    }
    //else //No format tag, so try the rest of this function.
  

    /* Add in a new section here.  Find out if there is an OLD permalink here. */
    /* NOTE ON TESTING THIS: this all works fine if you check the code in the same place.  That is, if you generate an old permalink
       using the local server, then you can check that the new code works correctly when you call the RL engine on the local server.
       And if you generate the link on the commercial server, then check by calling the engine on the commercial server. Don't mix the
       two servers.  The results will not match. */
    if(currentURL.indexOf("zoom")>0)
    {
	haveOldUrl = false;
	//alert("We appear to have an old URL to deal with.");
	// Get lat and lon
	p1 = currentURL.indexOf("ll=") + 3;
	p2 = currentURL.indexOf("%20",p1);
	val = currentURL.substring(p1,p2);
	if(val.length>0)
	{
	    oldUrlLng = parseFloat(val);
	}
	else return;
	//alert("The extracted LNG is " + oldUrlLng);
	
	p1 = p2+3;
	p2 = currentURL.indexOf("&",p1);
	val = currentURL.substring(p1,p2);
	if(val.length>0)
	{
	    oldUrlLat = parseFloat(val);
	}
	else return;
	//alert("The extracted LAT is " + oldUrlLat);
	
	p1 = p2+5;
	p2 = currentURL.indexOf("&",p1);
	val = currentURL.substring(p1,p2);
	if(val.length>0)
	{
	    oldUrlLen = parseFloat(val)*5280*12*2.54/100;
	}
	else return;
	//alert("The extracted LEN is " + oldUrlLen);
	
	p1 = p2+4;
	p2 = currentURL.indexOf("&",p1);
	val = currentURL.substring(p1,p2);
	if(val.length>0)
	{
	    oldUrlRnd = parseFloat(val);
	}
	else return;
	//alert("The extracted RND is " + oldUrlRnd);
	
	p1 = p2+4;
	p2 = currentURL.indexOf("&",p1);
	val = currentURL.substring(p1,p2);
	if(val.length>0)
	{
	    oldUrlAllow = val;
	}
	else return;
	//alert("The extracted ALLOW is " + oldUrlAllow);
	
	//If you reach this point, then:
	haveOldUrl = true;
	return;
    }
    //else, just continue with the rest of the routine.

    //alert("The current url is "+currentURL);
    var firstSplit = currentURL.split("?");
    //alert("At the first split we have "+firstSplit.length+" parts.");
    //for(var i=0;i<firstSplit.length;i++)alert("fS["+i+"] = "+firstSplit[i]);
    if(firstSplit.length==2)
    {
	var secondSplit = firstSplit[1].split("&");
	//alert("At the second split we have "+secondSplit.length+" parts.");
	for(var i=0;i<secondSplit.length;i++)
	{
	    //alert("sS["+i+"] = "+secondSplit[i]);
	    var hold = secondSplit[i].split("=");
	    urlInputsName[i] = hold[0];
	    urlInputsValue[i] = hold[1];
	    //alert("name["+i+"] "+urlInputsName[i]+" value "+urlInputsValue[i]);
	}
	//for(var i=0;i<urlInputsName.length;i++)alert("name["+i+"] "+urlInputsName[i]+" value "+urlInputsValue[i]);
	if(urlInputsName[0]=="Base")
	{
	    var hold = urlInputsValue[0].split(":");
	    var Lat = parseFloat(hold[0]);
	    var Lng = parseFloat(hold[1]);
	    uBase = new google.maps.LatLng(Lat,Lng);
	}
	else {return returnStatus;}
	if(urlInputsName[1]=="numWpts")
	{
	    var numWpts = parseInt(urlInputsValue[1]);
	}
	else {return returnStatus;}
	for(var i=0;i<numWpts;i++)
	{
	    if(urlInputsName[i+2]=="wpt["+i+"]")
	    {
		var hold = urlInputsValue[i+2].split(":");
		var Lat = parseFloat(hold[0]);
		var Lng = parseFloat(hold[1]);
		urlPoints[i] = new google.maps.LatLng(Lat,Lng);
	    }
	    else {return returnStatus;}
	}
	if(urlInputsName[numWpts+2]=="tM")
	{
	    utM = parseInt(urlInputsValue[numWpts+2]);
	}
	else {return returnStatus;}
	if(urlInputsName[numWpts+3]=="len")
	{
	    ulen = parseFloat(urlInputsValue[numWpts+3]);
	}
	else {return returnStatus;}
	if(urlInputsName[numWpts+4]=="unitS")
	{
	    uuS = parseInt(urlInputsValue[numWpts+4]);
	}
	else {return returnStatus;}
	if(urlInputsName[numWpts+5]=="doClean")
	{
	    uClean = (urlInputsValue[numWpts+5]);
	    returnStatus = true;
	    return returnStatus;
	}
	else{//Don't reqquire this doClean tag.
	    uClean=false;
	    //else {return returnStatus;}
	    //alert("The base location is " + BaseLocation.toString());
	    //alert("There are this many waypoints " + numWpts);
	    //for(var i=0;i<numWpts;i++)alert("Waypoint at " + rlPoints[i].toString());
	    //alert("The travel mode is " + travelMode);
	    returnStatus = true;
	    return returnStatus;
	}
    }
    else {return returnStatus;}
}

//...............................................................................
function buildDirections(directionResult)
{
    var myRoute = directionResult.routes[0].legs[0];
    var step = myRoute.steps.length;
    var cumulative=0;
    var cumWrite;
    Directions  = "<table border=1 rules=1>";
    Directions += "<tbody>";

    Directions += "<tr>";
    Directions += "<th colspan=4 align=left bgcolor='#ffec8b'>";
    Directions += "Start: " + myRoute.start_address;
    Directions += "</th>";
    Directions += "</tr>";

    Directions += "<tr>";
    Directions += "<td colspan=4 align=left>";
    Directions += "Total distance is " + totalDistanceInCurrentUnits.toFixed(2);
    if(document.getElementById("unitSystem").value==0)
	Directions += " mi.";
    else
	Directions += " km.";
    Directions += "</td>";
    Directions += "</tr>";

    if(directionResult.routes[0].warnings.length>0)
    {
	Directions += "<tr>";
	Directions += "<td colspan=4 align=left>";
	Directions += "<strong><i>" + directionResult.routes[0].warnings[0] + "</i></strong>";
	Directions += "</td>";
	Directions += "</tr>";
    }

    Directions += "<tr>";
    Directions += "<td></td> <td>Instruction</td> <td>Dist.</td> <td>Cum.<br>Dist.</td>";
    Directions += "</tr>";
    for(var i=0;i<step;i++)
    {
	//if(i>0 && j==0)continue; //Do not write this point since it is also the end of the last leg.
	//log(i +".  " +myRoute.steps[i].instructions+"  "+myRoute.steps[i].distance.text);
	Directions += "<tr>";

	cumulative += myRoute.steps[i].distance.value;
	if(document.getElementById("unitSystem").value==0)
	    cumWrite = cumulative*100/2.54/12/5280.;
	else
	    cumWrite = cumulative/1000;	    
	Directions += "<td>";
	Directions += i+1 +".";
	Directions += "</td>";

	Directions += "<td>";
	Directions += "<a href=\"javascript:showDirectionFlag("+i+")\">";
	Directions += myRoute.steps[i].instructions;
	Directions += "</a>";
	Directions += "</td>";

	Directions += "<td width='15%'>";
	Directions += myRoute.steps[i].distance.text;
	Directions += "</td>";

	Directions += "<td width='15%'>";
	if(document.getElementById("unitSystem").value==0)
	    Directions += cumWrite.toFixed(2) + "mi";
	else
	    Directions += cumWrite.toFixed(2) + "km";
	Directions += "</td>";

	Directions += "</tr>";
    }

    Directions += "<tr>";
    Directions += "<th colspan=4 align=left bgcolor='#ffec8b'>";
    // What follows is a sad little hack, because somehow end_address is not showing up in the response :-(  (Fixed now!!!)
    if(myRoute.end_address!=null)Directions += "End: " + myRoute.end_address;
    else Directions += "End: " + myRoute.start_address;
    Directions += "</th>";
    Directions += "</tr>";

    Directions += "<tr>";
    Directions += "<td colspan=4 align=left>";
    Directions += "<strong>" + directionResult.routes[0].copyrights + "</strong>";
    Directions += "</td>";
    Directions += "</tr>";

    Directions += "</tbody>";
    Directions += "</table>";

    document.getElementById("mydirectionsPanel").innerHTML = Directions;
}
//.................................................................................................

function buildRlUrl()
{
    RlUrl = new String();
    RlUrl += "http://www.routeloops.com/routeloops.php";
    //RlUrl += "http://localhost/routeloops2/routeloops.php";   //For use locally
    RlUrl += "?";

    //It's possible that there was an old permalink, in which case you want to build the URL here based on the old permalink information.
    if(haveOldUrl)
      {
	haveOldUrl = false;  // Turn this off so that you don't do this again.
	RlUrl += "x="+oldUrlLng;
	RlUrl += "&";
	RlUrl += "y="+oldUrlLat;
	RlUrl += "&";
	RlUrl += "length="+oldUrlLen;
	RlUrl += "&";
	RlUrl += "heading=-1";
	RlUrl += "&";
	RlUrl += "shape=-1";
	RlUrl += "&";
	RlUrl += "rand="+oldUrlRnd;
	RlUrl += "&";
	RlUrl += "allow="+oldUrlAllow;
	return;
      }
    //else, just continue with the rest of this function.

    RlUrl += "x="+BaseLocation.lng();
    RlUrl += "&";
    RlUrl += "y="+BaseLocation.lat();
 
    var length = document.getElementById("length").value;
    if(document.getElementById("unitSystem").value == 0)
	length = length*5280*12*2.54/100;
    else
	length = length*1000;
    RlUrl += "&";
    RlUrl += "length="+length;


    //With RouteLoops,
    // 0   degrees = North
    // 90  degrees = East
    // 180 degrees = South
    // 270 degrees = West
    if(travelHeading==0)
	var heading = Math.random()*2*180;  //in degrees
    else if(travelHeading==1) //this is North
    {
	var heading = Math.random()*180/4 - 1*180/8;
	if (heading<0)heading+=360;
    }
    else if(travelHeading==2) //this is Northeast
	var heading = Math.random()*180/4 + 180/8;
    else if(travelHeading==3) //this is East
	var heading = Math.random()*180/4 + 3*180/8;
    else if(travelHeading==4) //this is Southeast
	var heading = Math.random()*180/4 + 5*180/8;
    else if(travelHeading==5) //this is South
	var heading = Math.random()*180/4 + 7*180/8;
    else if(travelHeading==6) //this is Southwest
	var heading = Math.random()*180/4 + 9*180/8;
    else if(travelHeading==7) //this is West
	var heading = Math.random()*180/4 + 11*180/8;
    else if(travelHeading==8) //this is Northwest
	var heading = Math.random()*180/4 + 13*180/8;

    RlUrl += "&";
    RlUrl += "heading="+heading;

    RlUrl += "&";
    RlUrl += "shape=-1";

    RlUrl += "&";
    rnd = Math.random();
    //RlUrl += "rand=-1";
    RlUrl += "rand="+rnd;

    if(travelMode==0)
	var allow = "0%2C1%2C2%2C3";
    else if(travelMode==1)
	var allow = "0%2C1%2C4%2C5";
    else if(travelMode==2)
	var allow = "0%2C1%2C4%2C5%2C6";

    RlUrl += "&";
    RlUrl += "allow="+allow;

    return;
}
//...........................................................................................

function revertToPreviousRoute()
{
  historyPointer--;
  historyPointer = Math.max(historyPointer,0);

  thisRoute = resultHistory[historyPointer].RouteData.routes[0].legs[0];
  putTheseSettings(resultHistory[historyPointer].Settings);

  BaseLocation = new google.maps.LatLng(thisRoute.start_location.lat(),thisRoute.start_location.lng());
  document.getElementById("address").value = BaseLocation.toString();
  createBaseMarker();
  codeAddress();
  rlPoints.length = 0;
  for(var i=0;i<thisRoute.via_waypoint.length;i++)
    rlPoints.push(thisRoute.via_waypoint[i].location);

  document.getElementById("travelMode").value==resultHistory[historyPointer].Settings.travelMode;
  
  storeInHistory=false;
  if(pitchMarker)pitchMarker.setMap(null);
  calcRoute();

  return;
}
//....................................................................................
function advanceToNextRoute()
{

  historyPointer++;
  historyPointer = Math.min(historyPointer,resultHistory.length-1);

  thisRoute = resultHistory[historyPointer].RouteData.routes[0].legs[0];
  putTheseSettings(resultHistory[historyPointer].Settings);

  BaseLocation = new google.maps.LatLng(thisRoute.start_location.lat(),thisRoute.start_location.lng());
  document.getElementById("address").value = BaseLocation.toString();
  createBaseMarker();
  codeAddress();
  rlPoints.length = 0;
  for(var i=0;i<thisRoute.via_waypoint.length;i++)
    rlPoints.push(thisRoute.via_waypoint[i].location);

  document.getElementById("travelMode").value==resultHistory[historyPointer].Settings.travelMode;
  
  storeInHistory=false;
  if(pitchMarker)pitchMarker.setMap(null);
  calcRoute();

  return;
}
//....................................................................................
function createCookie(name, value, days)
{
  if (days) {
    var date = new Date();
    date.setTime(date.getTime()+(days*24*60*60*1000));
    var expires = "; expires="+date.toGMTString();
    }
  else var expires = "";
  document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/ ";

  return;
}
//......................................................................................

function readCookie(name)
{
  var ca = document.cookie.split(';');
  var nameEQ = name + "=";
  for(var i=0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0)==' ') c = c.substring(1, c.length); //delete spaces
    if (c.indexOf(nameEQ) == 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
    }
  return null;
}
//........................................................................................

function eraseCookie(name)
{
  createCookie(name, "", -1);
}
//.......................................................................................
function checkCookie()
{
  createCookie("cookieTest",1);
  if(readCookie("cookieTest")==1)return true;
  else return false;
}
//..........................................................
function cleanTails(response)
{
  //alert("Calling cleanTails!!!!");
  var pLpoints = new Array();
  var pLdist = new Array();
  var pLclose = new Array();
  var pLsep = new Array();
  var newPath = new Array();
  var pLuse = new Array();
  for(var i=0;i<routeLatLng.length;i++)
    {
      pLpoints.push(routeLatLng[i].location);
    }
  
  pLdist.push(0);
  var cumulative = 0;
  for(var i=0;i<pLpoints.length-1;i++)
    {
      pLuse[i] = false;
      cumulative += LatLngDist(pLpoints[i].lat(),pLpoints[i].lng(),pLpoints[i+1].lat(),pLpoints[i+1].lng());
      pLdist.push(cumulative);
      newPath.push(pLpoints[i]);
    }
  newPath.push(pLpoints[pLpoints.length-1]);
  //alert("Cumulative distance is " + cumulative);

  //Find the point, ahead of each point, to which each point is closest.
  var closest;
  var point;
  var dist;
  for(var i=0;i<pLpoints.length;i++)
    {
      var thisOne = pLpoints[i];
      for(var j=i+1;j<pLpoints.length;j++)
	{
	  thatOne = pLpoints[j];
	  dist = LatLngDist(thisOne.lat(),thisOne.lng(),thatOne.lat(),thatOne.lng());
	  if(j==i+1) //initialize
	    {
	      closest = dist;
	      point = j;
	    }
	  else
	    {
	      if(dist<closest) //store this point
		{
		  closest = dist;
		  point = j;
		}
	    }
	}
      pLclose[i] = point;
      pLsep[i] = closest;
    }


  var tailSize;
  for(var i=0;i<pLpoints.length;i++)
    {
      pLuse[i] = true;
      if(pLclose[i]-i != 1) //indicates a potential tail
	{
	  tailSize = (pLdist[pLclose[i]] - pLdist[i])/cumulative;
	  if(tailSize<0.2)
	    {	    
	      /*
	      var marker = new google.maps.Marker({
		position: pLpoints[i], 
		    map: map
		    });
	      attachInstructionText(marker, "Tail between" + i +","+ pLclose[i]);
	      */
	      i = pLclose[i]; //Jump ahead, over this tail.
	    }
	}
    }

    newPath.length = 0;
    for(var i=0;i<pLpoints.length;i++)
      if(pLuse[i])
	newPath.push(pLpoints[i]);
    
    var cleanedUp = pLpoints.length - newPath.length;
  
    //newPath should now hold the new path, without the tails.  Let's see.
    /*
      var np = new google.maps.Polyline({
      path: newPath,
      strokeColor: "#FF0000",
      strokeOpacity: 0.5,
      strokeWeight: 15
      });
      
      np.setMap(map);
    */
    
    //This may not be the best way, but I would like to find the points in this new path that are closest to the existing waypoints, and 
    //replace the existing waypoints with these new points.
    thisRoute = response.routes[0].legs[0];
    rlPointsNew.length = 0;
    for(var i=0;i<thisRoute.via_waypoint.length;i++)
      {
	for(var j=0;j<newPath.length;j++)
	  {
	    dist = LatLngDist(thisRoute.via_waypoint[i].location.lat(),thisRoute.via_waypoint[i].location.lng(),newPath[j].lat(),newPath[j].lng());
	    if(j==0)
	      {
		closest=dist;
		point=j;
	      }
	    else
	      {
		if(dist<closest)
		  {
		    closest = dist;
		    point=j;
		  }
	      }
	  }
	/*
	var marker = new google.maps.Marker({
	position: newPath[point], 
	map: map
	});
	attachInstructionText(marker, "New Waypoint" + i);
	*/
	rlPointsNew.push(newPath[point]);
      }
    
    rlPoints.length = 0;
    for(var i=0;i<rlPointsNew.length;i++)rlPoints.push(rlPointsNew[i]);
    //Don't let it move anything that is fixed.
    for(var i=0;i<fixedPoints.length;i++)rlPoints[i] = fixedPoints[i].marker.getPosition();
    
    return cleanedUp;
    
}
//...............................................................
function compareToPlan(response)
{
  
  retflag = true;

  var myRoute = response.routes[0].legs[0];

  // Check here to see if the route is just ridiculously off of plan.  Say by x2 or more.
  var length = document.getElementById("length").value;
  if(document.getElementById("unitSystem").value == 0)
    length = length*5280*12*2.54/100;
  else
    length = length*1000;
  //log("Desired length = " + length.toFixed(2));
  //log("Actual length  = " + myRoute.distance.value.toFixed(2));
  var ratio  = myRoute.distance.value/length;
  //log("Ratio is   = " + ratio);
  if(ratio>2)
    {
      //log("Ratio is > 2 " + ratio + " so, reinitializing." + "<br>");
      if(document.getElementById("unitSystem").value == 0)
	{
	  var have = myRoute.distance.value*100/2.54/12/5280;
	  var want = length*100/2.54/12/5280;
	}
      else
	{
	  var have = myRoute.distance.value/1000;
	  var want = length/1000;
	}      
      var answer = confirm("The current route length (" +have.toFixed(2)+ ") is too far from the requested distance (" +want.toFixed(2)+ "). \nClick 'OK' to update the desired route length and use this route. \nClick 'Cancel' to delete this route and generate a new one.");
      if(answer)
	{
	  document.getElementById("length").value = have;
	  length = have;
	  retflag = true;
	}
      else
	retflag = false;
    }
  else
    {
      //log("Ratio is <= 2 " + ratio + " so, not reinitializing." + "<br>");
      retflag = true;
    }

  // Here let's look for ferries.  If there are any, kill the route based on user preference.
  if(!allowFerries)
    {
      for(var i=0;i<myRoute.steps.length;i++)
	{
	  var tmp = myRoute.steps[i].instructions.toLowerCase();
	  if(tmp.indexOf("take the") >-1 && tmp.indexOf("ferry") > -1)
	    {
	      //alert("Ferry! " + myRoute.steps[i].instructions);
	      retflag = false;
	    }
	}
    }

  return retflag;
}
//............................................................................
function getLength()
{
    
    var length = document.getElementById("length").value;
    if(document.getElementById("unitSystem").value == 0)
    {
	length = length*5280*12*2.54/100;
	tcxSpeed = document.getElementById("tcxSpeed").value *(5280*12*2.54/100) /(60*60); //Convert to meters/second
    }
    else
    {
	length = length*1000;
	tcxSpeed = document.getElementById("tcxSpeed").value *(1000) /(60*60); //Convert to meters/second
    }
    requestedLengthInMeters = length;
    targetLengthInMeters = length;
    document.getElementById("GoButton").innerHTML="Create a Route of this Length";
    
    resetScale();
    
    return;
}
//....................................................................
function resetScale()
{
  scaleCount = 0;
  scaleFactor = 0.80;
  tooLong = 0;
  tooShort = 0;
  return;
}
//.....................................................................
function adjustScale()
{
  //Allow this scaling to change, based on how the program is doing at generating routes.
  if(totalDistanceInCurrentUnits==0)
    {
      scaleFactor = 0.80;
      scaleCount++;
      tooLong = 0;
      tooShort = 0;
    }
  else if (totalDistanceInCurrentUnits!=0 && scaleCount==0)
    {
      scaleCount++;
      tooLong = 0;
      tooShort = 0;
    }
  else if (totalDistanceInCurrentUnits!=0 && scaleCount!=0)
    {
      var lWanted = document.getElementById("length").value;
      if(totalDistanceInCurrentUnits<lWanted*0.9)
	{
	  tooLong = 0;
	  tooShort++;  //The routes are too short
	}
      else if(totalDistanceInCurrentUnits>lWanted*1.1)
	{
	  tooShort = 0;
	  tooLong++;  //The routes are too long
	}
      else // the route is fine.
	{
	  tooLong = 0;
	  tooShort = 0;
	}
      if(tooShort>2) //it's been too short for too long
	{
	  scaleFactor += 0.02;
	  scaleFactor = Math.min(scaleFactor,1.3);
	  tooShort = 0;
	  targetLengthInMeters *= scaleFactor;
	}
      if(tooLong>2) //it's been too long for too long
	{
	  scaleFactor -= 0.02;
	  scaleFactor = Math.max(scaleFactor,0.7);
	  tooLong = 0;
	  targetLengthInMeters *= scaleFactor;
	}
    }
  //alert("The scale factor I'm using is " + scaleFactor + "\n tooLong = " + tooLong + "\n tooShort = " + tooShort + "\n Target = " + targetLengthInMeters);
  
  return;
}
//............................................................................
function flagPoints()
{
  var dDd = routeResult.routes[0].legs[0];

  //Clear any existing flags.
    for (var i = 0; i < wayFlags.length; i++) {
      wayFlags[i].setMap(null);
    }
    wayFlags.length = 0;

  //Put little flags on the waypoints.
  for (var pnt in dDd.via_waypoint) 
    {
      var location = dDd.via_waypoint[pnt].location;
      var size = new google.maps.Size(60,44);
      var origin = new google.maps.Point(0,0);
      var anchor = new google.maps.Point(30,44);
      var scaledSize = new google.maps.Size(60,44);
      var flagNum = parseInt(pnt)+1;
      var file = "RLimages/Flag" + flagNum + ".png";
      var icon = new google.maps.MarkerImage(file,size,origin,anchor,scaledSize);
      var title = "Click the flag to delete waypoint #" + pnt;
      var waypointMarker = new google.maps.Marker({
        position: location,
	    map: map,
	    icon: icon,
	    clickable: true,
	    draggable: true,
	    title: title
	    });
      wayFlags.push(waypointMarker);

      google.maps.event.addListener(waypointMarker, 'click', function(mEvent) {
	  var close = 0;
	  var test = 0;
	  var kill = 0;
	  close = LatLngDist(mEvent.latLng.lat(),mEvent.latLng.lng(),
			     routeResult.routes[0].legs[0].via_waypoint[0].location.lat(),
			     routeResult.routes[0].legs[0].via_waypoint[0].location.lng());
	  for(var i=1;i<routeResult.routes[0].legs[0].via_waypoint.length;i++)
	    {
	      test = LatLngDist(mEvent.latLng.lat(),mEvent.latLng.lng(),
				routeResult.routes[0].legs[0].via_waypoint[i].location.lat(),
				routeResult.routes[0].legs[0].via_waypoint[i].location.lng());
	      if(test<close)
		{
		  close = test;
		  kill = i;
		}
	    }
	  var answer = confirm("The waypoint to be removed is at " + routeResult.routes[0].legs[0].via_waypoint[kill].location.toString() +"\n(Click 'Cancel' if you just want to move, not remove, the point.)");
	  if(answer)
	    {
	      routeResult.routes[0].legs[0].via_waypoint.splice(kill,1);
	      rlPoints = new Array();
	      for(var i=0;i<routeResult.routes[0].legs[0].via_waypoint.length;i++)
		{
		  rlPoints[i] = routeResult.routes[0].legs[0].via_waypoint[i].location;
		}
	      calcRoute();
	    }
	}); 
    } 
}
//....................................................................
function resetScale()
{

  scaleCount = 0;
  scaleFactor = 0.80;
  tooLong = 0;
  tooShort = 0;

  return;
}
//....................................................................
function extractLanguage()
{
  var currentURL = location.href;
  var protocol = location.protocol;
  var host = location.host;
  var path = location.pathname;
  //alert("URL " + currentURL + " protocol " + protocol + " host " + host + " path " + path);
  Language = "EN";
}
//......................................................................
function createSpacedPath()
{
  //The goal here is to create a version of the path that we now have, but with points more evenly spaced than
  //those returned by Google.

  spacedRouteData.length = 0;

  var spacing = 50; //the spacing between points in meters.  About 800 points in a 25 mile route.
  var inPoints = currentRouteData.length;
  var routeLength = currentRouteData[inPoints-1].dist;

  //So, store the first point in this new array.
  var Lat = currentRouteData[0].lat;
  var Lng = currentRouteData[0].lng;
  var temp = new routeData(Lat,Lng,0,0,0,false,false,"",false);
  spacedRouteData.push(temp);

  var currentDist = 0;
  var istart;
  while(currentDist<routeLength)
    {
      currentDist += spacing;
      if(currentDist>=routeLength)break;
      for(var i=0;i<inPoints;i++)
	if(currentRouteData[i].dist>currentDist)
	  break;
      var j = i;
      i--;
      //OK, we have the points we want to use.  Now interpolate between those points.
      //Lots of good material at http://www.movable-type.co.uk/scripts/latlong.html.
      var distToGo = currentDist - currentRouteData[i].dist;
      var Lat1 = currentRouteData[i].lat;
      var Lon1 = currentRouteData[i].lng;
      var Lat2 = currentRouteData[j].lat;
      var Lon2 = currentRouteData[j].lng;
      var lat1 = Lat1*Math.PI/180;
      var lat2 = Lat2*Math.PI/180;
      var lon1 = Lon1*Math.PI/180;
      var lon2 = Lon2*Math.PI/180;
      var R = 6371; // km
      var dLat = (lat2-lat1);
      var dLon = (lon2-lon1);

      //Get the bearing
      var y = Math.sin(dLon) * Math.cos(lat2);
      var x = Math.cos(lat1)*Math.sin(lat2) -
        Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      var brng = Math.atan2(y, x);

      //Now get the destination, given the starting point and the bearing
      var d = distToGo/1000;  //in km.
      var lat3 = Math.asin( Math.sin(lat1)*Math.cos(d/R) + 
			    Math.cos(lat1)*Math.sin(d/R)*Math.cos(brng) );
      var lon3 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(lat1), 
				   Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat3));

      var Lat3 = lat3*180/Math.PI;
      var Lon3 = lon3*180/Math.PI;

      var temp = new routeData(Lat3,Lon3,currentDist,0,0,false,false,"",false);
      spacedRouteData.push(temp);

      //var check = LatLngDist(Lat1,Lon1,Lat3,Lon3)*1000;
      
      //alert("At desired dist " + currentDist + " found point " + i + " with dist " + currentRouteData[i].dist + " followed by dist " + currentRouteData[j].dist);
      //alert("LatLng points were " + lat1*180/Math.PI + " " + lon1*180/Math.PI + " " + lat2*180/Math.PI + " " + lon2*180/Math.PI);
      //alert("Interped to " + lat3*180/Math.PI + " " + lon3*180/Math.PI + " which is separated by " + check + " meters" +"(" + distToGo + ")");

      //var spacedMarker = new google.maps.LatLng(Lat3,Lon3);
      //placeMarker(spacedMarker,currentDist.toString());
    }
  var Lat = currentRouteData[inPoints-1].lat;
  var Lng = currentRouteData[inPoints-1].lng;
  var temp = new routeData(Lat,Lng,routeLength,0,0,false,false,"",false);
  spacedRouteData.push(temp);

  return;
}

//...................................................................................
function makeHistory(result)
{

  var settingObject = new Object;
  settingObject.travelMode = document.getElementById("travelMode").value;
  settingObject.direction = document.getElementById("travelDirection").value;
  settingObject.heading = document.getElementById("travelHeading").value;
  settingObject.unit = document.getElementById("unitSystem").value;

  resultHistory.push({RouteData:result, Settings:settingObject});

  return;
}
//................................................................................
function putTheseSettings(settingObject)
{

  document.getElementById("travelMode").value = settingObject.travelMode;
  document.getElementById("travelDirection").value = settingObject.direction;
  document.getElementById("travelHeading").value = settingObject.heading;
  document.getElementById("unitSystem").value = settingObject.unit;
  
  return;
}
//.....................................................................................
function addruler()
{
  if(!measuring)
    {
      rulerMarkers.length = 0;
      measuring = true;
      map.setOptions({draggableCursor:'crosshair'});
      // Add a listener for the click events
      rulerClickListener = google.maps.event.addListener(map, 'click', rulerClickListen);
    }
  else
    {
      measuring = false;
      map.setOptions({draggableCursor:null});
      for(var i=0;i<rulerMarkers.length;i++)rulerMarkers[i].setMap(null);
      if(rulerLine)rulerLine.setMap(null);
      google.maps.event.removeListener(rulerClickListener);
      document.getElementById("RulerValue").innerHTML = "";
    }

  return;
}
//....................................................................
function rulerClickListen(event)
{

  if(rulerMarkers.length<2)
    {
      var loc = new google.maps.LatLng(event.latLng.lat(),event.latLng.lng());
      var marker = placeMarker(loc,"");
      marker.setDraggable(true);
      google.maps.event.addListener(marker,'dragend',drawTheRuler);
      rulerMarkers.push(marker);
    }
  else
    {
      if(rulerLine)rulerLine.setMap(null);
      while(rulerMarkers.length>=2)
	{
	  rulerMarkers[0].setMap(null);
	  rulerMarkers.splice(0,1);  //Remove stuff from this array until there is only 1 left.
	}
      //And now add the new one.
      var loc = new google.maps.LatLng(event.latLng.lat(),event.latLng.lng());
      var marker = placeMarker(loc,"");
      marker.setDraggable(true);
      rulerMarkers.push(marker);
    }

  if(rulerMarkers.length==2)
    {
      drawTheRuler();
    }

  return;
}
//.........................................................................
function drawTheRuler()
{

  if(rulerMarkers.length<2)return;

  //Remove the line.
  if(rulerLine)rulerLine.setMap(null);

  //Draw the line.
  rulerLine = new google.maps.Polyline({
    path: [rulerMarkers[0].getPosition(),rulerMarkers[1].getPosition()],
	strokeColor: "#FFFF00",
	strokeOpacity: 0.5,
	strokeWeight: 15,
	map:map
	});
  var Distance = LatLngDist(rulerMarkers[0].getPosition().lat(),rulerMarkers[0].getPosition().lng(),
			    rulerMarkers[1].getPosition().lat(),rulerMarkers[1].getPosition().lng());
  var DistanceMiles = Distance * KM2MILES;
  var msg = Distance.toFixed(1) + " km, " + DistanceMiles.toFixed(1) + " miles.";
  document.getElementById("RulerValue").innerHTML = msg;
  
  return;
}
//..........................................................................
function checkEmail(entry) 
{
  var email;
  if(entry==1)
    email = document.getElementById("emailField");
  else if(entry==2)
    email = document.getElementById("yourEmail");

  var filter = /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
  
  if (!filter.test(email.value)) {
    alert("Please provide a valid email address");
    email.value = "";
    email.focus;
    return false;
  }

  return;
}
